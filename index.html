<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Plaid Portfolio</title>
    <style>
        /* Matte black theme with subtle glows and polish */
        body {
            background-color: #111;
            color: #eee;
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            overflow-x: hidden;
        }
        .tabnav {
            display: flex;
            background: #222;
            border-bottom: 1px solid #333;
        }
        .tab {
            padding: 15px 20px;
            cursor: pointer;
            transition: background 0.3s;
        }
        .tab:hover {
            background: #333;
        }
        .tab.active {
            background: #444;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.1);
        }
        .content {
            display: none;
            padding: 20px;
        }
        .content.active {
            display: block;
        }
        #activity {
            display: flex;
        }
        .buy-column, .sell-column {
            width: 50%;
            min-height: 500px;
            padding: 10px;
            box-sizing: border-box;
        }
        .divider {
            width: 2px;
            background: linear-gradient(to bottom, #fff, #aaa);
            box-shadow: 0 0 5px rgba(255, 255, 255, 0.2);
        }
        .tile {
            padding: 15px;
            margin: 10px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.5);
            cursor: grab;
            transition: transform 0.2s, box-shadow 0.2s;
            animation: bounce 0.3s ease-in-out;
        }
        .tile:active {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.3);
        }
        @keyframes bounce {
            0% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
            100% { transform: translateY(0); }
        }
        #top-bar {
            background: #222;
            padding: 10px;
            margin-bottom: 20px;
            border-radius: 5px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            padding: 10px;
            border: 1px solid #333;
            text-align: left;
        }
        #modal {
            position: fixed;
            top: 20%;
            left: 30%;
            background: #222;
            padding: 20px;
            border: 1px solid #eee;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
            z-index: 10;
        }
        input, select, button {
            background: #333;
            color: #eee;
            border: 1px solid #444;
            padding: 5px;
            margin: 5px 0;
        }
        button {
            cursor: pointer;
        }
        canvas {
            background: #222;
            border: 1px solid #333;
            border-radius: 5px;
        }
        /* More polish: glow on hover */
        input:focus, select:focus {
            box-shadow: 0 0 5px rgba(255, 255, 255, 0.2);
        }
    </style>
</head>
<body>
    <nav class="tabnav">
        <div class="tab active" onclick="switchTab('dashboard')">Dashboard</div>
        <div class="tab" onclick="switchTab('activity')">Activity</div>
        <div class="tab" onclick="switchTab('analytics')">Analytics</div>
        <div class="tab" onclick="switchTab('simulator')">Margin Simulator</div>
        <div class="tab" onclick="switchTab('settings')">Settings</div>
    </nav>
    <div id="dashboard" class="content active">
        <div id="top-bar">Cash: <span id="cash">0</span> | Remaining Margin: <span id="margin">0</span></div>
        <table id="portfolio-list">
            <thead><tr><th>Ticker</th><th>Quantity</th><th>Avg Cost</th><th>Unrealized P/L</th></tr></thead>
            <tbody></tbody>
        </table>
        <canvas id="mini-chart" width="400" height="200"></canvas>
    </div>
    <div id="activity" class="content">
        <div class="buy-column" ondrop="drop(event)" ondragover="allowDrop(event)"></div>
        <div class="divider"></div>
        <div class="sell-column" ondrop="drop(event)" ondragover="allowDrop(event)"></div>
        <button onclick="addNewTrade()">+ Add Trade</button>
    </div>
    <div id="analytics" class="content">
        <div id="calendar" style="display: grid; grid-template-columns: repeat(7, 1fr); gap: 5px;"></div>
        <canvas id="radar-chart" width="400" height="400"></canvas>
        <canvas id="pie-ticker" width="200" height="200"></canvas>
        <canvas id="pie-asset" width="200" height="200"></canvas>
        <canvas id="spider-web" width="400" height="400"></canvas>
    </div>
    <div id="simulator" class="content">
        <label>Market Drop: <span id="drop-value">5</span>%</label>
        <input type="range" id="drop-slider" min="5" max="90" value="5" oninput="document.getElementById('drop-value').innerText = this.value; simulateDrop(this.value / 100)">
        <div id="equity-line"></div>
        <div id="suggestions"></div>
    </div>
    <div id="settings" class="content">
        <input id="starting-cash" placeholder="Starting Cash">
        <input id="margin-limit" placeholder="Margin Limit">
        <select id="api-type">
            <option>None</option>
            <option>Alpha Vantage</option>
            <option>Finnhub</option>
        </select>
        <input id="api-key" placeholder="API Key">
        <button onclick="saveSettings()">Save</button>
        <button onclick="toggleDemo()">Toggle Demo Mode</button>
        <button onclick="exportCSV()">Export CSV</button>
        <input type="file" id="import-file" onchange="importCSV(this.files[0])">
    </div>
    <canvas id="confetti-canvas" style="position: absolute; top:0; left:0; pointer-events: none; width: 100%; height: 100%;"></canvas>
    <div id="modal" style="display:none;">
        <form id="trade-form">
            <input type="date" id="trade-date">
            <input id="trade-ticker" placeholder="Ticker">
            <input type="number" id="trade-qty" placeholder="Quantity">
            <input type="number" id="trade-price" placeholder="Price/Premium">
            <select id="trade-type">
                <option>Stock</option>
                <option>Option</option>
            </select>
            <div id="option-fields" style="display:none;">
                <input type="number" id="trade-strike" placeholder="Strike">
                <input type="date" id="trade-expiry">
                <select id="trade-callput">
                    <option>Call</option>
                    <option>Put</option>
                </select>
            </div>
            <select id="trade-action">
                <option>Buy</option>
                <option>Sell</option>
            </select>
            <button type="button" onclick="saveTrade()">Save</button>
            <button type="button" onclick="hideModal()">Cancel</button>
        </form>
    </div>
    <script>
        // Erf polyfill
        function erf(x) {
            var z;
            const ERF_A = 0.147; 
            var the_sign_of_x;
            if(0==x) {
                the_sign_of_x = 0;
                return 0;
            } else if(x>0){
                the_sign_of_x = 1;
            } else {
                the_sign_of_x = -1;
            }

            var one_plus_axsqrd = 1 + ERF_A * x * x;
            var four_ovr_pi_etc = 4/Math.PI + ERF_A * x * x;
            var ratio = four_ovr_pi_etc / one_plus_axsqrd;
            ratio *= x * -x;
            var expofun = Math.exp(ratio);
            var radical = Math.sqrt(1-expofun);
            z = radical * the_sign_of_x;
            return z;
        }

        function cdf(x) {
            return (1.0 + erf(x / Math.sqrt(2.0))) / 2.0;
        }

        // Tab switching
        function switchTab(tabId) {
            document.querySelectorAll('.content').forEach(c => c.classList.remove('active'));
            document.getElementById(tabId).classList.add('active');
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.tab[onclick="switchTab('${tabId}')"]`).classList.add('active');
            loadDataForTab(tabId);
        }

        // IndexedDB setup
        let db;
        const request = indexedDB.open('PlaidPortfolio', 1);
        request.onupgradeneeded = (event) => {
            db = event.target.result;
            db.createObjectStore('trades', { autoIncrement: true });
            db.createObjectStore('settings', { keyPath: 'key' });
            db.createObjectStore('currentPrices', { keyPath: 'ticker' });
            db.createObjectStore('badges', { keyPath: 'name' });
        };
        request.onsuccess = (event) => {
            db = event.target.result;
            loadSettings();
            loadTrades();
        };
        request.onerror = (event) => console.error('IndexedDB error:', event.target.error);

        // Settings
        let settings = { startingCash: 100000, marginLimit: 50000, apiType: 'None', apiKey: '', demoMode: false };
        let cash = 100000;
        let trades = [];
        let holdings = {};
        let currentPrices = {};
        let confettos = [];
        let badges = [];

        function loadSettings() {
            const tx = db.transaction('settings');
            const store = tx.objectStore('settings');
            store.getAll().onsuccess = (event) => {
                event.target.result.forEach(item => settings[item.key] = item.value);
                cash = settings.startingCash;
                updateTopBar();
                if (settings.demoMode) loadDemoData();
            };
        }

        function saveSettings() {
            settings.startingCash = parseFloat(document.getElementById('starting-cash').value) || settings.startingCash;
            settings.marginLimit = parseFloat(document.getElementById('margin-limit').value) || settings.marginLimit;
            settings.apiType = document.getElementById('api-type').value;
            settings.apiKey = document.getElementById('api-key').value;
            const tx = db.transaction('settings', 'readwrite');
            const store = tx.objectStore('settings');
            Object.entries(settings).forEach(([key, value]) => store.put({ key, value }));
            cash = settings.startingCash;
            updateTopBar();
        }

        // Trades and holdings
        function loadTrades() {
            const tx = db.transaction('trades');
            const store = tx.objectStore('trades');
            store.getAll().onsuccess = (event) => {
                trades = event.target.result;
                updateHoldings();
                loadDataForTab(document.querySelector('.content.active').id);
            };
        }

        let currentEditKey = null;
        function saveTrade() {
            const trade = {
                date: document.getElementById('trade-date').value,
                ticker: document.getElementById('trade-ticker').value.toUpperCase(),
                qty: parseFloat(document.getElementById('trade-qty').value),
                price: parseFloat(document.getElementById('trade-price').value),
                type: document.getElementById('trade-type').value,
                action: document.getElementById('trade-action').value
            };
            if (trade.type === 'Option') {
                trade.strike = parseFloat(document.getElementById('trade-strike').value);
                trade.expiry = document.getElementById('trade-expiry').value;
                trade.isCall = document.getElementById('trade-callput').value === 'Call';
            }
            const tx = db.transaction('trades', 'readwrite');
            const store = tx.objectStore('trades');
            store.add(trade).onsuccess = () => {
                loadTrades();
                hideModal();
                if (trades.length >= 5) triggerAdvisor(trade);
            };
            currentEditKey = null;
        }

        function updateHoldings() {
            holdings = {};
            cash = settings.startingCash;
            trades.sort((a, b) => new Date(a.date) - new Date(b.date));
            trades.forEach(trade => {
                const key = getHoldingKey(trade);
                if (!holdings[key]) holdings[key] = { ...trade, qty: 0, totalCost: 0, buys: [] };
                const sign = trade.action === 'Buy' ? 1 : -1;
                if (trade.action === 'Buy') holdings[key].buys.push(trade);
                holdings[key].qty += sign * trade.qty;
                holdings[key].totalCost += sign * trade.qty * trade.price;
                if (holdings[key].qty > 0) holdings[key].avgCost = holdings[key].totalCost / holdings[key].qty;
                else delete holdings[key];
                cash -= sign * trade.qty * trade.price * (trade.type === 'Option' ? 100 : 1); // options contract size 100
            });
            updateTopBar();
        }

        function getHoldingKey(h) {
            return h.type === 'Stock' ? h.ticker : `${h.ticker}-${h.strike}-${h.expiry}-${h.isCall ? 'Call' : 'Put'}`;
        }

        // Modal
        function addNewTrade() {
            document.getElementById('trade-form').reset();
            document.getElementById('trade-date').valueAsDate = new Date();
            document.getElementById('trade-action').value = 'Buy';
            currentEditKey = null;
            showModal();
        }

        function editHolding(key) {
            const h = holdings[key];
            document.getElementById('trade-date').valueAsDate = new Date();
            document.getElementById('trade-ticker').value = h.ticker;
            document.getElementById('trade-qty').value = h.qty;
            document.getElementById('trade-price').value = '';
            document.getElementById('trade-type').value = h.type;
            document.getElementById('trade-action').value = 'Sell';
            if (h.type === 'Option') {
                document.getElementById('trade-strike').value = h.strike;
                document.getElementById('trade-expiry').value = h.expiry;
                document.getElementById('trade-callput').value = h.isCall ? 'Call' : 'Put';
            }
            currentEditKey = key;
            showModal();
        }

        function showModal() {
            document.getElementById('modal').style.display = 'block';
            document.getElementById('option-fields').style.display = document.getElementById('trade-type').value === 'Option' ? 'block' : 'none';
            document.getElementById('trade-type').onchange = (e) => document.getElementById('option-fields').style.display = e.target.value === 'Option' ? 'block' : 'none';
        }

        function hideModal() {
            document.getElementById('modal').style.display = 'none';
        }

        // API for prices and volatility
        async function updateCurrentPrices() {
            if (settings.apiType === 'None') return;
            const tickers = [...new Set(Object.values(holdings).map(h => h.ticker))];
            for (let ticker of tickers) {
                let priceUrl, ivUrl;
                if (settings.apiType === 'Alpha Vantage') {
                    priceUrl = `https://www.alphavantage.co/query?function=GLOBAL_QUOTE&symbol=${ticker}&apikey=${settings.apiKey}`;
                    // Alpha Vantage doesn't have free IV, so skip
                } else if (settings.apiType === 'Finnhub') {
                    priceUrl = `https://finnhub.io/api/v1/quote?symbol=${ticker}&token=${settings.apiKey}`;
                    ivUrl = `https://finnhub.io/api/v1/stock/option-chain?symbol=${ticker}&token=${settings.apiKey}`; // For IV, average or something
                }
                try {
                    const priceResponse = await fetch(priceUrl);
                    const priceData = await priceResponse.json();
                    if (settings.apiType === 'Alpha Vantage' && priceData['Global Quote']) {
                        currentPrices[ticker] = { price: parseFloat(priceData['Global Quote']['05. price']) };
                    } else if (settings.apiType === 'Finnhub') {
                        currentPrices[ticker] = { price: priceData.c };
                    }
                    if (ivUrl) {
                        const ivResponse = await fetch(ivUrl);
                        const ivData = await ivResponse.json();
                        // Simplistic: average IV from chain
                        let totalIV = 0, count = 0;
                        ivData.data.forEach(exp => exp.options.CALL.forEach(o => { totalIV += o.delta ? o.impliedVolatility : 0; count++; })); // approx
                        currentPrices[ticker].iv = count ? totalIV / count : 0.3;
                    } else {
                        currentPrices[ticker].iv = 0.3;
                    }
                } catch (e) {
                    console.error('API error:', e);
                }
            }
        }

        // Black-Scholes lite
        function blackScholes(S, K, T, r, sigma, isCall) {
            if (T <= 0) return isCall ? Math.max(S - K, 0) : Math.max(K - S, 0);
            let d1 = (Math.log(S / K) + (r + 0.5 * sigma * sigma) * T) / (sigma * Math.sqrt(T));
            let d2 = d1 - sigma * Math.sqrt(T);
            if (isCall) {
                return S * cdf(d1) - K * Math.exp(-r * T) * cdf(d2);
            } else {
                return K * Math.exp(-r * T) * cdf(-d2) - S * cdf(-d1);
            }
        }

        function estimateOptionValue(h) {
            const today = new Date('2025-09-28'); // Current date as per prompt
            const expiry = new Date(h.expiry);
            const days = Math.max(0, (expiry - today) / (1000 * 60 * 60 * 24));
            const T = days / 365;
            const S = currentPrices[h.ticker]?.price || h.price;
            const K = h.strike;
            const r = 0.05; // risk-free rate
            const sigma = currentPrices[h.ticker]?.iv || 0.3;
            return blackScholes(S, K, T, r, sigma, h.isCall);
        }

        // Load data for tabs
        async function loadDataForTab(tab) {
            await updateCurrentPrices();
            if (tab === 'dashboard') {
                const tbody = document.getElementById('portfolio-list').querySelector('tbody');
                tbody.innerHTML = '';
                let totalUnrealPL = 0;
                Object.values(holdings).forEach(h => {
                    let currentValue = h.type === 'Stock' ? (currentPrices[h.ticker]?.price || h.avgCost) : estimateOptionValue(h);
                    const pl = (currentValue - h.avgCost) * h.qty * (h.type === 'Option' ? 100 : 1);
                    totalUnrealPL += pl;
                    const row = tbody.insertRow();
                    row.innerHTML = `<td>${h.ticker}</td><td>${h.qty}</td><td>${h.avgCost.toFixed(2)}</td><td style="color: ${pl > 0 ? 'green' : 'red'}">${pl.toFixed(2)}</td>`;
                });
                drawMiniChart(); // Improved below
                const dailyPL = calculateDailyPL();
                if (dailyPL >= 10000) triggerConfetti();
                updateTopBar();
            } else if (tab === 'activity') {
                const buyCol = document.querySelector('.buy-column');
                const sellCol = document.querySelector('.sell-column');
                buyCol.innerHTML = '';
                sellCol.innerHTML = '';
                Object.entries(holdings).forEach(([key, h]) => {
                    const tile = createTile(h, 'buy');
                    tile.dataset.key = key;
                    tile.onclick = () => editHolding(key);
                    buyCol.appendChild(tile);
                    if (h.type === 'Option' && new Date(h.expiry) < new Date('2025-09-28')) {
                        const btn = document.createElement('button');
                        btn.innerText = 'Expired';
                        btn.onclick = () => expireOption(key);
                        tile.appendChild(btn);
                    }
                });
                trades.filter(t => t.action === 'Sell').forEach(t => {
                    const tile = createTile(t, 'sell');
                    sellCol.appendChild(tile);
                });
            } else if (tab === 'analytics') {
                buildCalendar();
                drawRadarChart();
                drawPieTicker();
                drawPieAsset();
                drawSpiderWeb();
            } else if (tab === 'simulator') {
                simulateDrop(document.getElementById('drop-slider').value / 100);
            }
        }

        function updateTopBar() {
            document.getElementById('cash').innerText = cash.toFixed(2);
            document.getElementById('margin').innerText = (settings.marginLimit + Math.max(0, cash)).toFixed(2); // Remaining margin
        }

        function createTile(data, type) {
            const tile = document.createElement('div');
            tile.classList.add('tile');
            tile.draggable = type === 'buy';
            tile.ondragstart = (ev) => ev.dataTransfer.setData('key', getHoldingKey(data));
            tile.innerText = `${data.ticker} x${data.qty} @${data.price ? data.price.toFixed(2) : data.avgCost.toFixed(2)}`;
            const size = Math.sqrt(data.qty) * 10 + 50; // Scaled
            tile.style.width = `${size}px`;
            tile.style.height = `${size / 2}px`;
            const totalQty = Object.values(holdings).reduce((sum, h) => sum + h.qty, 0) || 1;
            const intensity = Math.min(255, (data.qty / totalQty) * 200 + 55);
            tile.style.background = type === 'buy' ? `rgba(0, ${intensity}, 0, 0.8)` : `rgba(${intensity}, 0, 0, 0.8)`;
            return tile;
        }

        function allowDrop(ev) {
            ev.preventDefault();
        }

        function drop(ev) {
            ev.preventDefault();
            if (ev.target.closest('.sell-column')) {
                const key = ev.dataTransfer.getData('key');
                editHolding(key);
            }
        }

        function expireOption(key) {
            if (confirm('Confirm expiration? Value set to 0.')) {
                const h = holdings[key];
                const trade = { ...h, action: 'Sell', qty: h.qty, price: 0, date: new Date('2025-09-28').toISOString().split('T')[0] };
                const tx = db.transaction('trades', 'readwrite');
                tx.objectStore('trades').add(trade).onsuccess = loadTrades;
            }
        }

        // Confetti with dollar signs
        class Confetto {
            constructor(x, y, velocityX, velocityY) {
                this.x = x;
                this.y = y;
                this.size = Math.random() * 20 + 10;
                this.colors = ['#FFFFFF', '#FFD700', '#00FF00'];
                this.color = this.colors[Math.floor(Math.random() * this.colors.length)];
                this.velocityX = velocityX;
                this.velocityY = velocityY;
                this.gravity = 0.2;
                this.drag = 0.98;
                this.timeToLive = 5000;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotSpeed = Math.random() * 0.02 - 0.01;
                this.symbol = Math.random() > 0.5 ? '$' : ''; // Some dollars, some dots
            }
            draw(ctx) {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.fillStyle = this.color;
                ctx.font = `${this.size}px Arial`;
                ctx.fillText(this.symbol || '•', -this.size / 4, this.size / 4);
                ctx.restore();
            }
            update(deltaTime) {
                this.rotation += this.rotSpeed;
                this.x += this.velocityX;
                this.velocityX *= this.drag;
                this.y += this.velocityY;
                this.velocityY += this.gravity;
                this.size = Math.max(0, this.size - (this.size * deltaTime) / this.timeToLive);
            }
        }

        function triggerConfetti() {
            const canvas = document.getElementById('confetti-canvas');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            const ctx = canvas.getContext('2d');
            for (let i = 0; i < 300; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height / 2;
                const vx = Math.random() * 20 - 10;
                const vy = Math.random() * -20 - 10;
                confettos.push(new Confetto(x, y, vx, vy));
            }
            let lastTime = performance.now();
            function animate() {
                const currentTime = performance.now();
                const deltaTime = (currentTime - lastTime) / 1000 * 1000; // ms
                lastTime = currentTime;
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                confettos = confettos.filter(c => c.size > 0);
                confettos.forEach(c => {
                    c.update(deltaTime);
                    c.draw(ctx);
                });
                if (confettos.length > 0) requestAnimationFrame(animate);
            }
            animate();
            setTimeout(() => confettos = [], 5000);
        }

        // Advisor improved
        function triggerAdvisor(lastTrade) {
            let message = '';
            const lastPL = calculateTradePL(lastTrade);
            if (lastTrade.action === 'Sell') {
                if (lastPL > 0) message = 'Nice rug pull dodge.';
                else if (lastPL < 0) message = 'Paper hands—too quick! Diamond hands would\'ve mooned that.';
            } else if (lastTrade.action === 'Buy') {
                const holdTime = calculateAverageHoldTime();
                if (holdTime > 30) message = 'HODL king—respect through hell.';
            }
            if (message) {
                alert(message);
                checkBadges(message);
            }
        }

        function checkBadges(message) {
            let badgeName;
            if (message.includes('Diamond hands')) badgeName = 'Diamond Hands';
            else if (message.includes('HODL king')) badgeName = 'HODL King';
            if (badgeName) {
                const tx = db.transaction('badges', 'readwrite');
                tx.objectStore('badges').add({ name: badgeName });
                alert(`Unlocked badge: ${badgeName}`);
            }
        }

        function calculateTradePL(trade) {
            if (trade.action === 'Buy') return 0;
            // Find matching buys
            const key = getHoldingKey(trade);
            const matching = holdings[key] ? holdings[key].buys : [];
            let pl = 0;
            let remaining = trade.qty;
            for (let buy of matching) {
                const sellQty = Math.min(remaining, buy.qty);
                pl += (trade.price - buy.price) * sellQty * (trade.type === 'Option' ? 100 : 1);
                remaining -= sellQty;
                if (remaining <= 0) break;
            }
            return pl;
        }

        function calculateDailyPL() {
            const today = new Date('2025-09-28').toISOString().split('T')[0];
            let realized = 0;
            trades.filter(t => t.date === today && t.action === 'Sell').forEach(t => realized += calculateTradePL(t));
            let unrealized = 0;
            Object.values(holdings).forEach(h => {
                let cv = h.type === 'Stock' ? (currentPrices[h.ticker]?.price || h.avgCost) : estimateOptionValue(h);
                unrealized += (cv - h.avgCost) * h.qty * (h.type === 'Option' ? 100 : 1);
            });
            return realized + unrealized;
        }

        function calculateAverageHoldTime() {
            // Simple avg days held for sold positions
            let totalTime = 0, count = 0;
            trades.filter(t => t.action === 'Sell').forEach(sell => {
                const key = getHoldingKey(sell);
                const buys = holdings[key] ? holdings[key].buys : [];
                buys.forEach(buy => {
                    totalTime += (new Date(sell.date) - new Date(buy.date)) / (1000*60*60*24);
                    count++;
                });
            });
            return count ? totalTime / count : 0;
        }

        // Demo
        function toggleDemo() {
            settings.demoMode = !settings.demoMode;
            saveSettings();
            const tx = db.transaction('trades', 'readwrite');
            tx.objectStore('trades').clear();
            if (settings.demoMode) {
                const demoTrades = [
                    { date: '2025-09-01', ticker: 'TSLA', action: 'Buy', qty: 100, price: 200, type: 'Stock' },
                    { date: '2025-09-05', ticker: 'NVDA', action: 'Buy', qty: 50, price: 400, type: 'Stock' },
                    { date: '2025-09-10', ticker: 'TSLA', action: 'Sell', qty: 50, price: 220, type: 'Stock' },
                    { date: '2025-09-15', ticker: 'AAPL', action: 'Buy', qty: 200, price: 150, type: 'Stock' },
                    { date: '2025-09-20', ticker: 'SPY', action: 'Buy', qty: 10, price: 20, type: 'Option', strike: 400, expiry: '2025-12-31', isCall: false },
                    { date: '2025-09-25', ticker: 'TSLA', action: 'Buy', qty: 1, price: 65, type: 'Option', strike: 440, expiry: '2025-12-31', isCall: true },
                ];
                demoTrades.forEach(t => tx.objectStore('trades').add(t));
            }
            tx.oncomplete = loadTrades;
        }

        // CSV
        function exportCSV() {
            let csv = 'date,ticker,action,qty,price,type,P/L\n';
            trades.forEach(t => csv += `${t.date},${t.ticker},${t.action},${t.qty},${t.price},${t.type},${calculateTradePL(t)}\n`);
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'plaid_portfolio.csv';
            a.click();
        }

        function importCSV(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const lines = e.target.result.split('\n').slice(1);
                const tx = db.transaction('trades', 'readwrite');
                const store = tx.objectStore('trades');
                lines.forEach(line => {
                    if (!line) return;
                    const [date, ticker, action, qty, price, type, pl] = line.split(',');
                    const trade = { date, ticker, action, qty: parseFloat(qty), price: parseFloat(price), type };
                    if (type === 'Option') {
                        // Assume additional fields if needed, but for simplicity
                    }
                    store.add(trade);
                });
                tx.oncomplete = loadTrades;
            };
            reader.readAsText(file);
        }

        // Simulator
        async function simulateDrop(drop) {
            await updateCurrentPrices();
            let newEquity = cash;
            let liquidationRisk = false;
            Object.values(holdings).forEach(h => {
                const newS = (currentPrices[h.ticker]?.price || h.avgCost) * (1 - drop);
                let newValue;
                if (h.type === 'Stock') {
                    newValue = newS;
                } else {
                    const days = Math.max(0, (new Date(h.expiry) - new Date('2025-09-28')) / (1000 * 60 * 60 * 24));
                    const T = days / 365;
                    const r = 0.05;
                    const sigma = currentPrices[h.ticker]?.iv || 0.3;
                    newValue = blackScholes(newS, h.strike, T, r, sigma, h.isCall);
                }
                newEquity += newValue * h.qty * (h.type === 'Option' ? 100 : 1);
            });
            if (newEquity < 0) liquidationRisk = true;
            document.getElementById('equity-line').innerText = `Estimated Equity: $${newEquity.toFixed(2)}`;
            document.getElementById('simulator').style.background = liquidationRisk ? 'rgba(255,0,0,0.2)' : 'none';
            if (liquidationRisk) {
                const toAdd = -newEquity + 1;
                document.getElementById('suggestions').innerText = `Add $${toAdd.toFixed(2)} cash to avoid margin call.`;
            } else {
                document.getElementById('suggestions').innerText = '';
            }
        }

        // Analytics charts with canvas
        function buildCalendar() {
            const div = document.getElementById('calendar');
            div.innerHTML = '';
            const today = new Date('2025-09-28');
            for (let i = 0; i < 35; i++) { // Approx month
                const day = document.createElement('div');
                day.style.width = '30px';
                day.style.height = '30px';
                const date = new Date(today);
                date.setDate(today.getDate() - i);
                if (date.getDay() === 0 || date.getDay() === 6) {
                    day.style.background = '#333'; // Weekends blank-ish
                } else {
                    const pl = Math.random() * 2000 - 1000; // Fake PL for day
                    day.style.background = pl > 0 ? 'green' : 'red';
                    day.style.opacity = Math.min(Math.abs(pl) / 1000, 1);
                }
                div.appendChild(day);
            }
        }

        function drawRadarChart() {
            const ctx = document.getElementById('radar-chart').getContext('2d');
            const metrics = ['Win Rate', 'Avg Hold Time', 'Risk-Reward', 'Max Drawdown', 'Profit Factor', 'Consistency'];
            const values = [0.8, 15, 2.5, 0.2, 1.5, 0.9]; // Fake
            const max = Math.max(...values) * 1.2;
            const centerX = 200, centerY = 200, radius = 150;
            ctx.clearRect(0, 0, 400, 400);
            ctx.strokeStyle = '#eee';
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = i * Math.PI / 3;
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(centerX + radius * Math.cos(angle), centerY + radius * Math.sin(angle));
            }
            ctx.stroke();
            ctx.fillStyle = 'rgba(0,255,0,0.3)';
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const val = values[i] / max * radius;
                const angle = i * Math.PI / 3;
                const x = centerX + val * Math.cos(angle);
                const y = centerY + val * Math.sin(angle);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.closePath();
            ctx.fill();
            for (let i = 0; i < 6; i++) {
                const angle = i * Math.PI / 3;
                ctx.fillStyle = '#eee';
                ctx.fillText(metrics[i], centerX + (radius + 10) * Math.cos(angle) - 20, centerY + (radius + 10) * Math.sin(angle));
            }
        }

        function drawPieTicker() {
            const ctx = document.getElementById('pie-ticker').getContext('2d');
            const tickers = Object.keys(holdings).map(k => holdings[k].ticker);
            const allocations = Object.values(holdings).map(h => h.qty * h.avgCost);
            const total = allocations.reduce((a, b) => a + b, 0);
            let startAngle = 0;
            ctx.clearRect(0, 0, 200, 200);
            allocations.forEach((alloc, i) => {
                const slice = (alloc / total) * 2 * Math.PI;
                ctx.beginPath();
                ctx.moveTo(100, 100);
                ctx.arc(100, 100, 90, startAngle, startAngle + slice);
                ctx.fillStyle = ['#00ff00', '#ff0000', '#0000ff', '#ffff00'][i % 4];
                ctx.fill();
                startAngle += slice;
            });
        }

        function drawPieAsset() {
            const ctx = document.getElementById('pie-asset').getContext('2d');
            const assets = { Stock: 0, Option: 0 };
            Object.values(holdings).forEach(h => assets[h.type] += h.qty * h.avgCost);
            const total = Object.values(assets).reduce((a, b) => a + b, 0);
            let startAngle = 0;
            ctx.clearRect(0, 0, 200, 200);
            Object.entries(assets).forEach(([type, alloc], i) => {
                const slice = (alloc / total) * 2 * Math.PI;
                ctx.beginPath();
                ctx.moveTo(100, 100);
                ctx.arc(100, 100, 90, startAngle, startAngle + slice);
                ctx.fillStyle = i === 0 ? '#00ff00' : '#ff0000';
                ctx.fill();
                startAngle += slice;
            });
        }

        function drawSpiderWeb() {
            const ctx = document.getElementById('spider-web').getContext('2d');
            // Similar to radar, but multiple layers for historical
            ctx.fillText('Historical Spider Web Placeholder', 10, 50);
            // Todo: implement multiple radars over time
        }

        function drawMiniChart() {
            const ctx = document.getElementById('mini-chart').getContext('2d');
            ctx.clearRect(0, 0, 400, 200);
            ctx.strokeStyle = '#00ff00';
            ctx.beginPath();
            for (let i = 0; i < 30; i++) { // 30 days
                const pl = Math.random() * 10000 - 5000; // Fake
                const x = i * (400 / 30);
                const y = 100 - (pl / 100);
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();
        }

        // Initial load
        switchTab('dashboard');
    </script>
</body>
</html>
