<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Plaid Portfolio - Trading Cockpit</title>
    <style>
        :root {
            --bg-primary: #0a0a0a;
            --bg-secondary: #141414;
            --bg-tertiary: #1a1a1a;
            --text-primary: #ffffff;
            --text-secondary: #a0a0a0;
            --text-disabled: #4a4a4a;
            --accent-green: #00ff88;
            --accent-red: #ff3366;
            --accent-gold: #ffd700;
            --accent-blue: #00a8ff;
            --border-color: #2a2a2a;
            --glow-green: 0 0 20px rgba(0, 255, 136, 0.4);
            --glow-red: 0 0 20px rgba(255, 51, 102, 0.4);
            --glow-gold: 0 0 30px rgba(255, 215, 0, 0.6);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        .top-bar {
            background: var(--bg-secondary);
            padding: 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .app-title {
            font-size: 24px;
            font-weight: 700;
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-green));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            letter-spacing: 1px;
        }

        .balance-info {
            display: flex;
            gap: 30px;
        }

        .balance-item {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }

        .balance-label {
            color: var(--text-secondary);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .balance-value {
            font-size: 24px;
            font-weight: bold;
            margin-top: 5px;
        }

        .balance-value.positive {
            color: var(--accent-green);
            text-shadow: var(--glow-green);
        }

        .balance-value.negative {
            color: var(--accent-red);
            text-shadow: var(--glow-red);
        }

        .tabs {
            display: flex;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
        }

        .tab {
            padding: 15px 30px;
            cursor: pointer;
            border: none;
            background: none;
            color: var(--text-secondary);
            font-size: 14px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        .tab:hover {
            color: var(--text-primary);
        }

        .tab.active {
            color: var(--accent-green);
        }

        .tab.active::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: var(--accent-green);
            box-shadow: var(--glow-green);
        }

        .content {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
        }

        .tab-content {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        /* Dashboard Styles */
        .dashboard {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 20px;
            height: 100%;
        }

        .portfolio-section {
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid var(--border-color);
        }

        .section-title {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 20px;
            color: var(--text-primary);
        }

        .holdings-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .holdings-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0 10px;
        }

        .holdings-table th {
            text-align: left;
            color: var(--text-secondary);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            padding: 10px;
        }

        .holdings-table td {
            padding: 15px 10px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 14px;
        }

        /* Fix width for the "Current" column in both tables */
        #stocksTable th:nth-child(4),
        #stocksTable td:nth-child(4),
        #optionsTable th:nth-child(6),
        #optionsTable td:nth-child(6) {
            width: 120px;          /* tweak to taste */
            white-space: nowrap;   /* prevents wrapping */
        }

        /* If you made the cell editable with an <input>, make it fill the cell neatly */
        #stocksTable td:nth-child(4) input,
        #optionsTable td:nth-child(6) input {
            width: 100%;
            max-width: 120px;
            box-sizing: border-box;
        }


        .holdings-table tr td:first-child {
            border-radius: 8px 0 0 8px;
        }

        .holdings-table tr td:last-child {
            border-radius: 0 8px 8px 0;
        }

.holdings-table td input[type="number"] {
    width: 100%;
    background: transparent;
    border: none;
    color: var(--text-primary);
    font: inherit;
    text-align: left;
    padding: 0;
}
.holdings-table td input[type="number"]:focus {
    outline: none;
    box-shadow: 0 0 0 1px var(--accent-blue) inset;
    border-radius: 4px;
}


        .ticker-symbol {
            font-weight: 600;
            font-size: 16px;
        }

        .pnl-positive {
            color: var(--accent-green);
            font-weight: 600;
        }

        .pnl-negative {
            color: var(--accent-red);
            font-weight: 600;
        }   
        .pnl-negative { color: crimson; font-weight: 600; }   /* requested crimson */
        .pnl-zero     { color: #9CA3AF; font-weight: 600; }   /* neutral for 0.00 */

        .chart-container {
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid var(--border-color);
        }

        .mini-chart {
            height: 200px;
            display: flex;
            align-items: flex-end;
            justify-content: space-around;
            margin-top: 20px;
        }

        .chart-bar {
            width: 20px;
            background: linear-gradient(to top, var(--accent-green), var(--accent-blue));
            border-radius: 4px 4px 0 0;
            transition: height 0.3s ease;
        }

        .chart-bar.negative {
            background: linear-gradient(to bottom, var(--accent-red), #ff6666);
            border-radius: 0 0 4px 4px;
        }


        /* Activity Tab Styles */
        .activity-container {
            display: grid;
            grid-template-columns: 1fr 1px 1fr;
            gap: 20px;
            height: calc(100vh - 200px);
        }

        .activity-column {
            padding: 20px;
            background: var(--bg-tertiary);
            border-radius: 12px;
            border: 1px solid var(--border-color);
            overflow-y: auto;
            position: relative;
        }

        .column-title {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 20px;
            text-align: center;
        }

        .buy-column .column-title {
            color: var(--accent-green);
        }

        .sell-column .column-title {
            color: var(--accent-red);
        }

        .divider {
            background: linear-gradient(to bottom, var(--accent-blue), transparent, var(--accent-blue));
            width: 1px;
        }

        
        
        .tiles-container {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            position: relative;
            min-height: 400px;
        }

        .trade-tile {
            padding: 15px;
            border-radius: 8px;
            cursor: grab;
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            position: relative;
            overflow: hidden;
            min-width: 150px;
            min-height: 180px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .trade-tile:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            z-index: 10;
        }

        .trade-tile:active {
            cursor: grabbing;
            transform: scale(1.05);
        }

       .trade-tile.grayed {
            opacity: 0.3;
            pointer-events: none;   /* block tile interactions */
            background: var(--bg-secondary) !important;
            border-color: var(--text-disabled) !important;
            position: relative;
        }

        .trade-tile.grayed .tile-delete-btn {
            pointer-events: auto;   /* re-enable interaction for delete button */
        }


        .trade-tile.countdown {
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .buy-tile {
            background: linear-gradient(135deg, rgba(0, 255, 136, 0.1), rgba(0, 255, 136, 0.05));
            border: 1px solid rgba(0, 255, 136, 0.3);
        }

        .sell-tile {
            background: linear-gradient(135deg, rgba(255, 51, 102, 0.1), rgba(255, 51, 102, 0.05));
            border: 1px solid rgba(255, 51, 102, 0.3);
        }

        .tile-ticker {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 8px;
        }

        .tile-details {
            display: flex;
            justify-content: space-between;
            color: var(--text-secondary);
            font-size: 12px;
            margin-bottom: 4px;
        }

        .tile-actions {
            position: absolute;
            top: 5px;
            right: 5px;
            display: flex;
            gap: 5px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        .trade-tile:hover .tile-actions {
            opacity: 1;
        }

        .tile-action-btn {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: var(--text-primary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            transition: all 0.2s;
        }

        .tile-action-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }

        .countdown-timer {
            position: absolute;
            bottom: 5px;
            right: 5px;
            color: var(--accent-gold);
            font-size: 16px;
            font-weight: bold;
        }

        /* Fix option tile text legibility */
.trade-tile {
    font-size: 13px;          /* smaller, consistent base font */
    line-height: 1.4;         /* improve spacing */
}

.trade-tile .tile-ticker {
    font-size: 16px;          /* keep ticker bold and readable */
    margin-bottom: 6px;
}

.trade-tile .tile-details {
    flex-direction: column;   /* stack text vertically for clarity */
    align-items: flex-start;
    gap: 2px;                 /* small gap between lines */
    font-size: 12px;
    line-height: 1.3;
    word-break: break-word;   /* prevents overflow */
}

/* Ensure premium/date rows are always visible */
.trade-tile .tile-details span {
    display: block;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 100%;
}
        /*  Expanded option tile */
        /*  Expanded option tile */
        .trade-tile.expanded {
        height: auto !important;     /* let tile grow vertically */
        min-height: 180px;           /* baseline so it feels balanced */
        white-space: normal;         /* allow wrapping */
        cursor: default;
        }

        /* Delete button for grayed-out tiles */
        .tile-delete-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 22px;
            height: 22px;
            border-radius: 4px;
            background: rgba(255, 0, 0, 0.2);
            border: 1px solid rgba(255, 0, 0, 0.4);
            color: var(--accent-red);
            font-size: 14px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.8;
            transition: all 0.2s;
            z-index: 20;
        }

        .tile-delete-btn:hover {
            background: rgba(255, 0, 0, 0.3);
            transform: scale(1.1);
            opacity: 1;
        }



        /* Ledger Tab */
        .ledger-container {
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid var(--border-color);
        }

        .ledger-filters {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            align-items: center;
        }

        .filter-input {
            padding: 8px 12px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 14px;
        }

        .ledger-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0 5px;
        }

        .ledger-table th {
            text-align: left;
            color: var(--text-secondary);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            padding: 10px;
            background: var(--bg-secondary);
            position: sticky;
            top: 0;
        }

        .ledger-table td {
            padding: 12px 10px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 13px;
        }

        /* Analytics Tab */
        .analytics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 400px;
            gap: 20px;
        }
        
        @media (max-width: 1400px) {
            .analytics-grid {
                grid-template-columns: 1fr 1fr;
            }
        }
        
        @media (max-width: 900px) {
            .analytics-grid {
                grid-template-columns: 1fr;
            }
        }

        .analytics-card {
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid var(--border-color);
        }

        .calendar-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .calendar-nav-btn {
            padding: 5px 10px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s;
        }

        .calendar-nav-btn:hover {
            background: var(--bg-primary);
        }

        .calendar-month {
            font-size: 16px;
            font-weight: 600;
        }

        .calendar-weekdays {
            display: grid;
            grid-template-columns: repeat(5, 1fr) 60px;
            gap: 5px;
            margin-bottom: 5px;
        }

        .calendar-weekday {
            text-align: center;
            color: var(--text-secondary);
            font-size: 12px;
            font-weight: 600;
            padding: 5px;
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr) 60px;
            gap: 5px;
        }

        .calendar-day {
            aspect-ratio: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            background: var(--bg-secondary);
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
        }

        .calendar-day:hover {
            transform: scale(1.1);
            z-index: 10;
        }

        .calendar-day.profit {
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid rgba(0, 255, 136, 0.4);
        }

        .calendar-day.loss {
            background: rgba(255, 51, 102, 0.2);
            border: 1px solid rgba(255, 51, 102, 0.4);
        }

        .calendar-day-number {
            font-weight: bold;
        }

        .calendar-day-pnl {
            font-size: 10px;
            color: var(--text-secondary);
        }

        .calendar-week-total {
            background: var(--bg-primary);
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            font-weight: 600;
            font-size: 12px;
        }

        .calendar-week-total.positive {
            color: var(--accent-green);
        }

        .calendar-week-total.negative {
            color: var(--accent-red);
        }

        .radar-chart-container, .pie-chart-container {
            position: relative;
            width: 100%;
            height: 350px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Margin Simulator */
        .simulator-container {
            max-width: 800px;
            margin: 0 auto;
        }

        .simulator-card {
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 20px;
            border: 1px solid var(--border-color);
        }

        .slider-container {
            margin: 30px 0;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            color: var(--text-secondary);
        }

        .slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: var(--bg-secondary);
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--accent-blue);
            cursor: pointer;
            box-shadow: var(--glow-gold);
            transition: all 0.2s ease;
        }

        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .warning-box {
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
            display: none;
        }

        .warning-box.active {
            display: block;
            background: rgba(255, 51, 102, 0.1);
            border: 1px solid var(--accent-red);
            animation: warningPulse 2s infinite;
        }

        @keyframes warningPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Settings Tab */
        .settings-section {
            max-width: 600px;
            margin: 0 auto;
        }

        .setting-group {
            background: var(--bg-tertiary);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid var(--border-color);
        }

        .input-group {
            margin-bottom: 20px;
        }

        .input-group label {
            display: block;
            color: var(--text-secondary);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        .input-group input,
        .input-group select {
            width: 100%;
            padding: 12px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 14px;
        }

        .input-group input:focus,
        .input-group select:focus {
            outline: none;
            border-color: var(--accent-blue);
            box-shadow: 0 0 10px rgba(0, 168, 255, 0.2);
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-green));
            color: var(--text-primary);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(0, 168, 255, 0.3);
        }

        .btn-secondary {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
        }

        .btn-secondary:hover {
            background: var(--bg-tertiary);
        }

        .toggle-switch {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
        }

        .switch {
            position: relative;
            width: 50px;
            height: 26px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .switch-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-secondary);
            transition: 0.3s;
            border-radius: 26px;
        }

        .switch-slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
            background: var(--text-secondary);
            transition: 0.3s;
            border-radius: 50%;
        }

        input:checked + .switch-slider {
            background: var(--accent-green);
        }

        input:checked + .switch-slider:before {
            transform: translateX(24px);
            background: white;
        }

        /* Confetti Animation */
        .confetti {
            position: fixed;
            width: 10px;
            height: 10px;
            top: -10px;
            animation: confetti-fall 5s linear;
            z-index: 9999;
        }

        @keyframes confetti-fall {
            to {
                transform: translateY(120vh) rotate(720deg);
            }
        }

        /* AI Advisor Popup */
        .ai-popup {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: linear-gradient(135deg, var(--bg-tertiary), var(--bg-secondary));
            border: 1px solid var(--accent-blue);
            border-radius: 12px;
            padding: 20px;
            max-width: 300px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            animation: slideIn 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            display: none;
        }

        .ai-popup.active {
            display: block;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .ai-popup-title {
            font-size: 14px;
            color: var(--accent-blue);
            margin-bottom: 10px;
            font-weight: 600;
        }

        .ai-popup-message {
            font-size: 13px;
            color: var(--text-primary);
            line-height: 1.5;
        }

        /* Modal Styles */
        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--bg-secondary);
            border-radius: 12px;
            padding: 30px;
            max-width: 500px;
            width: 90%;
            border: 1px solid var(--border-color);
        }

        .modal-header {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 20px;
            color: var(--text-primary);
        }

        .modal-body {
            margin-bottom: 20px;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        /* Loading Animation */
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid var(--bg-tertiary);
            border-top: 3px solid var(--accent-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Floating Action Button */
        .fab {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-green));
            color: white;
            border: none;
            font-size: 30px;
            cursor: pointer;
            box-shadow: 0 10px 30px rgba(0, 168, 255, 0.3);
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            z-index: 999;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .fab:hover {
            transform: scale(1.1) rotate(90deg);
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-secondary);
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Top Bar -->
        <div class="top-bar">
            <h1 class="app-title">PLAID PORTFOLIO</h1>
            <div class="balance-info">
                <div class="balance-item">
                    <span class="balance-label">Cash Balance</span>
                    <span class="balance-value positive" id="cashBalance">$100,000</span>
                </div>
                <div class="balance-item">
                    <span class="balance-label">Margin Available</span>
                    <span class="balance-value" id="marginBalance">$50,000</span>
                </div>
                <div class="balance-item">
                    <span class="balance-label">Total Buying Power</span>
                    <span class="balance-value" id="totalBuyingPower">$150,000</span>
                </div>
                <div class="balance-item">
                    <span class="balance-label">Daily P/L</span>
                    <span class="balance-value" id="dailyPnl">+$0</span>
                </div>
            </div>
        </div>

        <!-- Tab Navigation -->
        <div class="tabs">
            <button class="tab active" data-tab="dashboard">Dashboard</button>
            <button class="tab" data-tab="activity">Activity</button>
            <button class="tab" data-tab="ledger">Ledger</button>
            <button class="tab" data-tab="analytics">Analytics</button>
            <button class="tab" data-tab="simulator">Margin Simulator</button>
            <button class="tab" data-tab="settings">Settings</button>
        </div>

        <!-- Content Area -->
        <div class="content">
            <!-- Dashboard Tab -->
            <div id="dashboard" class="tab-content active">
                <div class="dashboard">
                    <div class="portfolio-section">
                        <div class="holdings-container">
                            <!-- Stocks Holdings -->
                            <div>
                                <h2 class="section-title">Stock Holdings</h2>
                                <table class="holdings-table" id="stocksTable">
                                    <thead>
                                        <tr>
                                            <th>Ticker</th>
                                            <th>Shares</th>
                                            <th>Avg Cost</th>
                                            <th>Current</th>
                                            <th>P/L</th>
                                            <th>% Change</th>
                                        </tr>
                                    </thead>
                                    <tbody id="stocksHoldingsBody">
                                        <!-- Stock holdings will be populated here -->
                                    </tbody>
                                </table>
                            </div>

                            <!-- Options Holdings -->
                            <div>
                                <h2 class="section-title">Options Holdings</h2>
                                <table class="holdings-table" id="optionsTable">
                                    <thead>
                                        <tr>
                                            <th>Ticker</th>
                                            <th>Type</th>
                                            <th>Strike/Exp</th>
                                            <th>Contracts</th>
                                            <th>Premium</th>
                                            <th>Current</th>
                                            <th>P/L</th>
                                        </tr>
                                    </thead>
                                    <tbody id="optionsHoldingsBody">
                                        <!-- Options holdings will be populated here -->
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                    <div>
                        <div class="chart-container">
                            <h3 class="section-title">P/L Trend</h3>
                            <div class="mini-chart" id="miniChart">
                                <!-- Chart bars will be generated here -->
                            </div>
                        </div>
                        <div class="chart-container" style="margin-top: 20px;">
                            <h3 class="section-title">Quick Stats</h3>
                            <div style="padding: 20px;">
                                <div style="margin-bottom: 15px;">
                                    <span style="color: var(--text-secondary);">Win Rate:</span>
                                    <span style="float: right; color: var(--accent-green);" id="winRate">0%</span>
                                </div>
                                <div style="margin-bottom: 15px;">
                                    <span style="color: var(--text-secondary);">Total Trades:</span>
                                    <span style="float: right;" id="totalTrades">0</span>
                                </div>
                                <div style="margin-bottom: 15px;">
                                    <span style="color: var(--text-secondary);">Best Trade:</span>
                                    <span style="float: right; color: var(--accent-green);" id="bestTrade">$0</span>
                                </div>
                                <div>
                                    <span style="color: var(--text-secondary);">Locked Collateral:</span>
                                    <span style="float: right;" id="lockedCollateral">$0</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Activity Tab -->
            <div id="activity" class="tab-content">
                <div class="activity-container">
                    <div class="activity-column buy-column">
                        <h2 class="column-title">BUY POSITIONS</h2>
                        <div id="buyTiles" class="tiles-container">
                            <!-- Buy tiles will be populated here -->
                        </div>
                    </div>
                    <div class="divider"></div>
                    <div class="activity-column sell-column">
                        <h2 class="column-title">SELL POSITIONS</h2>
                        <div id="sellTiles" class="tiles-container">
                            <!-- Sell tiles will be populated here -->
                        </div>
                    </div>
                </div>
            </div>

            <!-- Ledger Tab -->
            <div id="ledger" class="tab-content">
                <div class="ledger-container">
                    <h2 class="section-title">Transaction Ledger</h2>
                    <div class="ledger-filters">
                        <input type="text" class="filter-input" id="tickerFilter" placeholder="Filter by ticker...">
                        <input type="date" class="filter-input" id="startDateFilter">
                        <span style="color: var(--text-secondary);">to</span>
                        <input type="date" class="filter-input" id="endDateFilter">
                        <button class="btn btn-secondary" onclick="filterLedger()">Filter</button>
                        <button class="btn btn-secondary" onclick="clearLedgerFilters()">Clear</button>
                    </div>
                    <div style="overflow-x: auto;">
                        <table class="ledger-table">
                            <thead>
                                <tr>
                                    <th>Date/Time</th>
                                    <th>Action</th>
                                    <th>Ticker</th>
                                    <th>Type</th>
                                    <th>Strike/Expiry</th>
                                    <th>Quantity</th>
                                    <th>Avg Cost</th>
                                    <th>Price</th>
                                    <th>Total</th>
                                    <th>P/L</th>
                                    <th>Balance</th>

                                </tr>
                            </thead>
                            <tbody id="ledgerBody">
                                <!-- Ledger entries will be populated here -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <!-- Analytics Tab -->
            <div id="analytics" class="tab-content">
                <div class="analytics-grid">
                    <div class="analytics-card">
                        <h3 class="section-title">Trading Calendar</h3>
                        <div class="calendar-container">
                            <div class="calendar-header">
                                <button class="calendar-nav-btn" onclick="changeMonth(-1)">←</button>
                                <div class="calendar-month" id="calendarMonth">January 2025</div>
                                <button class="calendar-nav-btn" onclick="changeMonth(1)">→</button>
                            </div>
                            <div class="calendar-weekdays">
                                <div class="calendar-weekday">Mon</div>
                                <div class="calendar-weekday">Tue</div>
                                <div class="calendar-weekday">Wed</div>
                                <div class="calendar-weekday">Thu</div>
                                <div class="calendar-weekday">Fri</div>
                                <div class="calendar-weekday">Week</div>
                            </div>
                            <div class="calendar-grid" id="tradingCalendar">
                                <!-- Calendar will be generated here -->
                            </div>
                        </div>
                    </div>
                    
                    <div class="analytics-card">
                        <h3 class="section-title">Performance Metrics</h3>
                        <div class="radar-chart-container">
                            <canvas id="radarChart" width="350" height="350"></canvas>
                        </div>
                    </div>
                    
                    <div class="analytics-card">
                        <h3 class="section-title">Portfolio Allocation</h3>
                        <div class="pie-chart-container">
                            <canvas id="pieChart" width="350" height="350"></canvas>
                        </div>
                    </div>
                    
                    <div class="analytics-card">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <h3 class="section-title" style="margin-bottom: 0;">Balance Over Time</h3>
                            <div style="display: flex; gap: 10px;">
                                <select id="balanceChartType" onchange="updateBalanceChart()" style="padding: 5px 10px; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 12px;">
                                    <option value="line">Line</option>
                                    <option value="bar">Bar</option>
                                </select>
                                <select id="balanceChartRange" onchange="updateBalanceChart()" style="padding: 5px 10px; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 12px;">
                                    <option value="7">7 Days</option>
                                    <option value="30" selected>30 Days</option>
                                    <option value="90">90 Days</option>
                                    <option value="365">1 Year</option>
                                    <option value="all">All Time</option>
                                </select>
                            </div>
                        </div>
                        <div style="position: relative; width: 100%; height: 300px;">
                            <canvas id="balanceChart" width="400" height="300"></canvas>
                        </div>
                    </div>

                    <div class="analytics-card">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <h3 class="section-title" style="margin-bottom: 0;">P/L Over Time</h3>
                            <div style="display: flex; gap: 10px;">
                                <select id="pnlChartType" onchange="updatePnLChart()" style="padding: 5px 10px; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 12px;">
                                    <option value="bar">Bar</option>
                                    <option value="line">Line</option>
                                </select>
                                <select id="pnlChartRange" onchange="updatePnLChart()" style="padding: 5px 10px; background: var(--bg-secondary); border: 1px solid var(--border-color); border-radius: 4px; color: var(--text-primary); font-size: 12px;">
                                    <option value="7">7 Days</option>
                                    <option value="30" selected>30 Days</option>
                                    <option value="90">90 Days</option>
                                    <option value="365">1 Year</option>
                                    <option value="all">All Time</option>
                                </select>
                            </div>
                        </div>
                        <div style="position: relative; width: 100%; height: 300px;">
                            <canvas id="pnlChart" width="400" height="300"></canvas>
                        </div>
                    </div>


                    <div class="analytics-card">
                        <h3 class="section-title">Trading Statistics</h3>
                        <div style="padding: 20px;">
                            <div style="margin-bottom: 20px;">
                                <div style="color: var(--text-secondary); margin-bottom: 5px;">YTD Profit</div>
                                <div style="font-size: 24px; font-weight: bold;" id="ytdProfit">$0</div>
                            </div>
                            <div style="margin-bottom: 20px;">
                                <div style="color: var(--text-secondary); margin-bottom: 5px;">30-Day Profit</div>
                                <div style="font-size: 24px; font-weight: bold;" id="profit30d">$0</div>
                            </div>
                            <div style="margin-bottom: 20px;">
                                <div style="color: var(--text-secondary); margin-bottom: 5px;">7-Day Profit</div>
                                <div style="font-size: 24px; font-weight: bold;" id="profit7d">$0</div>
                            </div>
                            <div style="margin-bottom: 20px;">
                                <div style="color: var(--text-secondary); margin-bottom: 5px;">Profit Factor</div>
                                <div style="font-size: 24px; font-weight: bold;" id="profitFactor">0.00</div>
                            </div>
                            <div style="margin-bottom: 20px;">
                                <div style="color: var(--text-secondary); margin-bottom: 5px;">Max Drawdown</div>
                                <div style="font-size: 24px; font-weight: bold; color: var(--accent-red);" id="maxDrawdown">0%</div>
                            </div>
                            <div style="margin-bottom: 20px;">
                                <div style="color: var(--text-secondary); margin-bottom: 5px;">Avg Hold Time</div>
                                <div style="font-size: 24px; font-weight: bold;" id="avgHoldTime">0 days</div>
                            </div>
                            <div>
                                <div style="color: var(--text-secondary); margin-bottom: 5px;">Risk/Reward Ratio</div>
                                <div style="font-size: 24px; font-weight: bold;" id="riskReward">0.00</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Margin Simulator Tab -->
            <div id="simulator" class="tab-content">
                <div class="simulator-container">
                    <div class="simulator-card">
                        <h2 class="section-title">Market Drop Simulator</h2>
                        <div class="slider-container">
                            <div class="slider-label">
                                <span>Market Drop</span>
                                <span id="dropValue">0%</span>
                            </div>
                            <input type="range" class="slider" id="marketDropSlider" min="0" max="90" value="0">
                        </div>
                        <div style="margin-top: 30px;">
                            <div style="display: flex; justify-content: space-between; margin-bottom: 15px;">
                                <span>Portfolio Value:</span>
                                <span id="simPortfolioValue" style="font-weight: bold;">$0</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; margin-bottom: 15px;">
                                <span>Equity:</span>
                                <span id="simEquity" style="font-weight: bold;">$0</span>
                            </div>
                            <div style="display: flex; justify-content: space-between;">
                                <span>Margin Used:</span>
                                <span id="simMarginUsed" style="font-weight: bold;">$0</span>
                            </div>
                        </div>
                        <div class="warning-box" id="marginWarning">
                            <h3 style="color: var(--accent-red); margin-bottom: 10px;">⚠️ MARGIN CALL RISK</h3>
                            <p>Your account would face liquidation at this market drop level. Consider adding <span id="cashNeeded" style="font-weight: bold;">$0</span> in cash to avoid margin call.</p>
                        </div>
                    </div>
                    
                    <div class="simulator-card">
                        <h3 class="section-title">Options Impact</h3>
                        <div id="optionsImpact">
                            <p style="color: var(--text-secondary);">No options positions to simulate</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Settings Tab -->
            <div id="settings" class="tab-content">
                <div class="settings-section">
                    <div class="setting-group">
                        <h3 class="section-title">Account Configuration</h3>
                        <div class="input-group">
                            <label>Starting Cash</label>
                            <input type="number" id="startingCash" value="100000">
                        </div>
                        <div class="input-group">
                            <label>Margin Limit</label>
                            <input type="number" id="marginLimit" value="50000">
                        </div>
                        <button class="btn btn-primary" onclick="saveAccountSettings()">Save Settings</button>
                    </div>

                    <div class="setting-group">
                        <h3 class="section-title">API Integration</h3>
                        <div class="toggle-switch">
                            <span>Enable Real-Time Data</span>
                            <label class="switch">
                                <input type="checkbox" id="apiToggle">
                                <span class="switch-slider"></span>
                            </label>
                        </div>
                        <div class="input-group">
                            <label>API Provider</label>
                            <select id="apiProvider">
                                <option value="none">None</option>
                                <option value="alphavantage">Alpha Vantage</option>
                                <option value="finnhub">Finnhub</option>
                            </select>
                        </div>
                        <div class="input-group">
                            <label>API Key</label>
                            <input type="password" id="apiKey" placeholder="Enter your API key">
                        </div>
                    </div>

                    <div class="setting-group">
                        <h3 class="section-title">Demo Mode</h3>
                        <div class="toggle-switch">
                            <span>Load Demo Data (30 days)</span>
                            <label class="switch">
                                <input type="checkbox" id="demoToggle" onchange="toggleDemoData()">
                                <span class="switch-slider"></span>
                            </label>
                        </div>
                        <p style="color: var(--text-secondary); margin-top: 10px; font-size: 12px;">
                            Loads sample trades for TSLA, NVDA, AAPL, SPY including options (within cash+margin limits)
                        </p>
                    </div>

                    <div class="setting-group">
                        <h3 class="section-title">Data Management</h3>
                        <div style="display: flex; gap: 10px;">
                            <button class="btn btn-secondary" onclick="exportData()">Export CSV</button>
                            <button class="btn btn-secondary" onclick="document.getElementById('csvImport').click()">Import CSV</button>
                            <input type="file" id="csvImport" style="display: none;" accept=".csv" onchange="importData(event)">
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Trade Entry Modal -->
    <div class="modal" id="tradeModal">
        <div class="modal-content">
            <div class="modal-header">Add Trade</div>
            <div class="modal-body">
                <div class="input-group">
                    <label>Date</label>
                    <input type="date" id="tradeDate">
                </div>
                <div class="input-group">
                    <label>Ticker</label>
                    <input type="text" id="tradeTicker" placeholder="TSLA">
                </div>
                <div class="input-group">
                    <label>Type</label>
                    <select id="tradeType" onchange="updateTradeForm()">
                        <option value="stock">Stock</option>
                        <option value="buy_call">Buy Call</option>
                        <option value="sell_call">Sell Call</option>
                        <option value="buy_put">Buy Put</option>
                        <option value="sell_put">Sell Put</option>
                    </select>
                </div>
                <div class="input-group">
                    <label>Quantity / Contracts</label>
                    <input type="number" id="tradeQuantity" placeholder="100">
                </div>
                <div class="input-group">
                    <label>Price per Share / Premium per Contract</label>
                    <input type="number" id="tradePrice" step="0.01" placeholder="450.00">
                </div>
                <div class="input-group" id="optionFields" style="display: none;">
                    <label>Strike Price</label>
                    <input type="number" id="strikePrice" step="0.01">
                    <label style="margin-top: 10px;">Expiry Date</label>
                    <input type="date" id="expiryDate">
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
                <button class="btn btn-primary" onclick="saveTrade()">Add Trade</button>
            </div>
        </div>
    </div>

    <!-- Sell Price Modal -->
    <div class="modal" id="sellPriceModal">
        <div class="modal-content">
            <div class="modal-header">Enter Sell Price</div>
            <div class="modal-body">
                <div class="input-group">
                    <label>Sell Price per Share</label>
                    <input type="number" id="sellPrice" step="0.01" placeholder="0.00">
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeSellModal()">Cancel</button>
                <button class="btn btn-primary" onclick="confirmSell()">Confirm Sale</button>
            </div>
        </div>
    </div>

    <!-- Split Tile Modal -->
    <div class="modal" id="splitModal">
        <div class="modal-content">
            <div class="modal-header">Split Position</div>
            <div class="modal-body">
                <p id="splitInfo" style="margin-bottom: 20px; color: var(--text-secondary);"></p>
                <div class="input-group">
                    <label>Quantity to Split</label>
                    <input type="number" id="splitQuantity" placeholder="0">
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeSplitModal()">Cancel</button>
                <button class="btn btn-primary" onclick="confirmSplit()">Split</button>
            </div>
        </div>
    </div>

    <!-- Close Option Modal -->
    <div class="modal" id="closeOptionModal">
        <div class="modal-content">
            <div class="modal-header">Close Sold Option</div>
            <div class="modal-body">
                <div class="input-group">
                    <label>Was the option exercised?</label>
                    <select id="optionExercised">
                        <option value="false">No</option>
                        <option value="true">Yes</option>
                    </select>
                </div>
                <div class="input-group">
                    <label>Did the option expire worthless?</label>
                    <select id="optionExpired">
                        <option value="false">No - I'm closing early</option>
                        <option value="true">Yes - Expired worthless</option>
                    </select>
                </div>
                <div class="input-group" id="closePremiumGroup">
                    <label>Premium Paid to Close (per contract)</label>
                    <input type="number" id="closePremium" step="0.01" placeholder="0.00">
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeCloseOptionModal()">Cancel</button>
                <button class="btn btn-primary" onclick="confirmCloseOption()">Close Position</button>
            </div>
        </div>
    </div>

    <!-- AI Advisor Popup -->
    <div class="ai-popup" id="aiPopup">
        <div class="ai-popup-title">🤖 AI Trading Advisor</div>
        <div class="ai-popup-message" id="aiMessage"></div>
    </div>

    <!-- Floating Action Button -->
    <button class="fab" onclick="openTradeModal()">+</button>

    <script>
        // Core App State
        let appState = {
            cash: 100000,
            marginAvailable: 50000,
            marginUsed: 0,
            lockedCollateral: 0,
            lockedShares: {},  // ADD THIS LINE - tracks locked shares by ticker
            positions: [],
            ledger: [],
            currentMonth: new Date().getMonth(),
            currentYear: new Date().getFullYear(),
            prices: { stocks: {}, options: {} },
            settings: {
                apiEnabled: false,
                apiProvider: 'none',
                apiKey: '',
                demoMode: false,
                startingCash: 100000,
                marginLimit: 50000
            },
            tradeCount: 0
            
        };

        // Temporary state for operations
        let draggedTile = null;
        let currentSplitTrade = null;
        let currentSellTrade = null;

        // Initialize IndexedDB
        let db;
        const dbName = 'PlaidPortfolioDB';
        const dbVersion = 2;

        function initDB() {
    // IndexedDB disabled per request; using localStorage only.
    try {
        if (typeof loadFromLocalStorage === 'function') {
            loadFromLocalStorage();
        }
    } catch (e) {
        console.error('InitDB disabled, using localStorage:', e);
    }
}


        // Tab Navigation
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', function() {
                const tabName = this.dataset.tab;
                
                // Update active tab
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                this.classList.add('active');
                
                // Update active content
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                document.getElementById(tabName).classList.add('active');
                
                // Load tab-specific data
                loadTabData(tabName);
            });
        });

        // Load tab data
        function loadTabData(tabName) {
            switch(tabName) {
                case 'dashboard':
                    updateDashboard();
                    break;
                case 'activity':
                    loadActivityTiles();
                    break;
                case 'ledger':
                    updateLedger();
                    break;
                case 'analytics':
                    updateAnalytics();
                    break;
                case 'simulator':
                    updateSimulator();
                    break;
            }
        }

        // Global number formatter for 2 decimals
        function formatNumber(value) {
            if (isNaN(value) || value === null) return '0.00';
            return parseFloat(value).toFixed(2);
        }

        // Utility Functions (integer formatting for big counters)
        // Avoid shadowing the global 2-decimal formatter above.
        function formatInt(num) {
            const n = Number(num) || 0;
            return n.toLocaleString('en-US', { minimumFractionDigits: 0, maximumFractionDigits: 0 });
        }


        // Balance Management Functions
        function updateBalances() {
            const cashEl = document.getElementById('cashBalance');
            const marginEl = document.getElementById('marginBalance');
            const buyingPowerEl = document.getElementById('totalBuyingPower');
            
            cashEl.textContent = '$' + formatInt(appState.cash);
            cashEl.className = appState.cash >= 0 ? 'balance-value positive' : 'balance-value negative';
            
           marginEl.textContent = '$' + formatInt(appState.marginAvailable);
            marginEl.className = appState.marginAvailable >= 0 ? 'balance-value positive' : 'balance-value negative';
            
            const totalBuyingPower = appState.cash + appState.marginAvailable;
            buyingPowerEl.textContent = '$' + formatInt(totalBuyingPower);
            
            // Update locked collateral in quick stats
            const lockedEl = document.getElementById('lockedCollateral');
            if (lockedEl) {
               lockedEl.textContent = '$' + formatInt(appState.lockedCollateral);
            }
            
            // Calculate daily P/L from ledger
            const today = new Date().toISOString().split('T')[0];
            const todayEntries = appState.ledger.filter(entry => 
                entry.timestamp && entry.timestamp.startsWith(today)
            );
            
            const dailyPnl = todayEntries.reduce((sum, entry) => sum + (entry.pnl || 0), 0);
            const pnlEl = document.getElementById('dailyPnl');
            pnlEl.textContent = (dailyPnl > 0 ? '+' : dailyPnl < 0 ? '-' : '') + '$' + Math.abs(dailyPnl).toFixed(2);
            pnlEl.className = dailyPnl > 0 ? 'balance-value positive' :
                            dailyPnl < 0 ? 'balance-value negative' : 'balance-value';

            
        }

        function deductFromBalance(amount) {
            if (appState.cash >= amount) {
                appState.cash -= amount;
            } else {
                const remainingAmount = amount - appState.cash;
                appState.cash = 0;
                appState.marginAvailable -= remainingAmount;
                appState.marginUsed += remainingAmount;
            }
            updateBalances();
        }

        function addToBalance(amount) {
            if (appState.marginUsed > 0) {
                const marginRepay = Math.min(amount, appState.marginUsed);
                appState.marginAvailable += marginRepay;
                appState.marginUsed -= marginRepay;
                appState.cash += (amount - marginRepay);
            } else {
                appState.cash += amount;
            }
            updateBalances();
        }

        // Dashboard Functions
        function updateDashboard() {
            updateStocksHoldings();
            updateOptionsHoldings();
            updatePnLChart();
            updateQuickStats();
        }

        function updateStocksHoldings() {
            const tbody = document.getElementById('stocksHoldingsBody');
            tbody.innerHTML = '';
            
            // Group stock positions by ticker
            const stockPositions = {};
            appState.positions.filter(p => p.type === 'stock' && p.status === 'open').forEach(position => {
                if (!stockPositions[position.ticker]) {
                    stockPositions[position.ticker] = {
                        quantity: 0,
                        totalCost: 0,
                        currentPrice: 0
                    };
                }
                stockPositions[position.ticker].quantity += position.quantity;
                stockPositions[position.ticker].totalCost += position.quantity * position.price;
                // Simulate current price

                // Use manual override if available, otherwise simulate
                stockPositions[position.ticker].currentPrice = position.currentPrice 
                    ? position.currentPrice 
                    : position.price * (1 + (Math.random() * 0.2 - 0.1));
             });
            
            Object.keys(stockPositions).forEach(ticker => {
            const pos = stockPositions[ticker];
            const avgCost = pos.totalCost / pos.quantity;

            // prefer manual override; fallback to avg cost as a neutral baseline
            const manual = appState.prices?.stocks?.[ticker];
            const currentPrice = (typeof manual === 'number') ? manual : avgCost;

            const currentValue = pos.quantity * currentPrice;
            const pnl = currentValue - pos.totalCost;
            const pnlPercent = (pnl / pos.totalCost) * 100;

            const row = document.createElement('tr');
            row.innerHTML = `
            <td><span class="ticker-symbol">${ticker}</span></td>
            <td>${pos.quantity}</td>
            <td>$${avgCost.toFixed(2)}</td>
            <td>
                <input type="number" step="0.01"
                    value="${currentPrice.toFixed(2)}"
                    onchange="updateManualPrice('${ticker}', this.value)">
            </td>
            <td class="${pnl >= 0 ? 'pnl-positive' : 'pnl-negative'}">
                ${pnl >= 0 ? '+' : ''}$${Math.abs(pnl).toFixed(2)}
            </td>
            <td class="${pnl >= 0 ? 'pnl-positive' : 'pnl-negative'}">
                ${pnl >= 0 ? '+' : ''}${pnlPercent.toFixed(2)}%
            </td>


                `;
                tbody.appendChild(row);
            });
        }

    function updateOptionsHoldings() {
    const tbody = document.getElementById('optionsHoldingsBody');
    tbody.innerHTML = '';

    // Group options by ticker + type + strike + expiry
    const optionGroups = {};
    appState.positions
        .filter(p => p.type !== 'stock' && p.status === 'open')
        .forEach(p => {
            const key = `${p.ticker}_${p.type}_${p.strike}_${p.expiry}`;
            if (!optionGroups[key]) {
                optionGroups[key] = {
                    groupKey: key,                                // <- keep, don't overwrite later
                    ticker: p.ticker,
                    optionType: p.type.replace(/_/g, ' ').toUpperCase(),
                    strike: p.strike,                             // keep the original value for key stability
                    expiry: p.expiry,
                    contracts: 0,
                    totalPremium: 0
                };
            }
            // ACCUMULATE (do NOT reassign the whole object)
            const qty = Number(p.quantity) || 0;
            const prem = (typeof p.premium === 'number') ? p.premium : Number(p.price) || 0;
            optionGroups[key].contracts += qty;
            optionGroups[key].totalPremium += qty * prem;
        });

    // Build rows
    Object.values(optionGroups).forEach(option => {
        if (option.contracts <= 0) return; // nothing to show

        const avgPremium = option.totalPremium / option.contracts;
        const manual = appState.prices?.options?.[option.groupKey];
        const currentPremium = (typeof manual === 'number') ? manual : avgPremium;

        const pnl = (currentPremium - avgPremium) * option.contracts * 100;

        const row = document.createElement('tr');
        row.innerHTML = `
            <td><span class="ticker-symbol">${option.ticker}</span></td>
            <td>${option.optionType}</td>
            <td>$${option.strike} / ${option.expiry}</td>
            <td>${option.contracts}</td>
            <td>$${avgPremium.toFixed(2)}</td>
            <td>
                <input type="number" step="0.01"
                       value="${currentPremium.toFixed(2)}"
                       onchange="updateManualPremium('${option.ticker}', '${option.strike}', '${option.expiry}', '${option.optionType}', this.value)">
            </td>
            <td class="${pnl >= 0 ? 'pnl-positive' : 'pnl-negative'}">
                ${pnl >= 0 ? '+' : ''}$${Math.abs(pnl).toFixed(2)}
            </td>

        `;
        tbody.appendChild(row);
    });
}


function updateManualPrice(ticker, newValue) {
    const price = parseFloat(newValue);
    if (isNaN(price) || price <= 0) return;

    if (!appState.prices) appState.prices = { stocks: {}, options: {} };
    if (!appState.prices.stocks) appState.prices.stocks = {};
    appState.prices.stocks[ticker] = price;   // only this ticker

    saveData();
    updateDashboard();
}

function updateManualPremium(ticker, strike, expiry, optionType, newValue) {
    const premium = parseFloat(newValue);
    if (isNaN(premium) || premium <= 0) return;

    // "BUY CALL" -> "buy_call"
    const typeKey = optionType.toLowerCase().replace(/\s+/g, '_');
    const groupKey = `${ticker}_${typeKey}_${strike}_${expiry}`;

    if (!appState.prices) appState.prices = { stocks: {}, options: {} };
    if (!appState.prices.options) appState.prices.options = {};
    appState.prices.options[groupKey] = premium;  // only this option group

    saveData();
    updateDashboard();
}

        
        function updatePnLChart() {
            const chart = document.getElementById('miniChart');
            chart.innerHTML = '';
            
            // Get last 7 days of P/L from ledger
            const last7Days = [];
            for (let i = 6; i >= 0; i--) {
                const date = new Date();
                date.setDate(date.getDate() - i);
                const dateStr = date.toISOString().split('T')[0];
                
                const dayEntries = appState.ledger.filter(entry => 
                    entry.timestamp && entry.timestamp.startsWith(dateStr)
                );
                const dayPnl = dayEntries.reduce((sum, entry) => sum + (entry.pnl || 0), 0);
                last7Days.push(dayPnl);
            }
            
            const maxPnl = Math.max(...last7Days.map(Math.abs), 100);
            
            last7Days.forEach(pnl => {
                const bar = document.createElement('div');
                bar.className = 'chart-bar';
                const height = Math.abs(pnl) / maxPnl * 100;
                bar.style.height = height + '%';
                if (pnl < 0) {
                    bar.classList.add('negative');
                }
                chart.appendChild(bar);
            });
        }

        function updateQuickStats() {
            const completedTrades = appState.ledger.filter(entry => entry.action === 'sell' && entry.pnl !== undefined);
            const winningTrades = completedTrades.filter(t => t.pnl > 0);
            const winRate = completedTrades.length > 0 ? (winningTrades.length / completedTrades.length * 100) : 0;
            
            document.getElementById('winRate').textContent = winRate.toFixed(1) + '%';
            document.getElementById('totalTrades').textContent = appState.ledger.length;
            
            const bestTrade = Math.max(...completedTrades.map(t => t.pnl || 0), 0);
            document.getElementById('bestTrade').textContent = '$' + formatInt(bestTrade);
        
            // Update locked collateral display
            const lockedEl = document.getElementById('lockedCollateral');
            if (lockedEl) {
                let lockedValue = appState.lockedCollateral;
                // Add value of locked shares
                Object.keys(appState.lockedShares || {}).forEach(ticker => {
                    const qty = appState.lockedShares[ticker];
                    const price = appState.prices?.stocks?.[ticker] || 0;
                    lockedValue += qty * price;
                });
                lockedEl.textContent = '$' + formatInt(lockedValue);
            }
        }

// ---- Signed formatting helpers (2 decimals everywhere) ----
function signedParts(value, { isCurrency = false, suffix = '' } = {}) {
    const v = Number(value) || 0;
    const sign = v > 0 ? '+' : v < 0 ? '-' : '';
    const abs = Math.abs(v);

    const body = isCurrency
        ? `$${abs.toFixed(2)}`
        : `${abs.toFixed(2)}${suffix}`;

    const cls = v > 0 ? 'pos' : v < 0 ? 'neg' : 'zero';
    return { text: `${sign}${body}`, cls: `pl-signed ${cls}` };
}

// Apply signed text + class to a cell/element
function setSignedText(el, value, opts) {
    const { text, cls } = signedParts(value, opts);
    el.textContent = text;
    el.classList.remove('pl-signed', 'pos', 'neg', 'zero');
    cls.split(' ').forEach(c => el.classList.add(c));
}


        // Activity Tab Functions
        function loadActivityTiles() {
            // Fix frozen countdown tiles on page load
            appState.positions.forEach(position => {
                if (position.countdown !== undefined && position.countdown !== null) {
                    // If countdown exists but hasn't been grayed, immediately gray it
                    // (assume time passed during page reload)
                    if (!position.grayed) {
                        position.grayed = true;
                        position.countdown = null;
                    }
                }
            });
            
            const buyTiles = document.getElementById('buyTiles');
            const sellTiles = document.getElementById('sellTiles');
            
            buyTiles.innerHTML = '';
            sellTiles.innerHTML = '';
            
            // ... rest of the function continues unchanged
            
            // Calculate total portfolio value
            const totalPortfolioValue = appState.positions
                .filter(p => p.status === 'open')
                .reduce((sum, p) => {
                    if (p.type === 'stock') {
                        return sum + (p.quantity * p.price);
                    } else {
                        return sum + (p.quantity * p.premium * 100);
                    }
                }, 0);
            
            appState.positions.filter(p => p.status === 'open').forEach((position, index) => {
                const tile = createTradeTile(position, totalPortfolioValue);
                
                // Sell options go directly to sell side
                if ((position.type === 'sell_call' || position.type === 'sell_put')) {
                    sellTiles.appendChild(tile);
                } else if (position.side === 'sell') {
                    sellTiles.appendChild(tile);
                } else {
                    buyTiles.appendChild(tile);
                }
            });
            
            enableDragAndDrop();
        }

         function enableTileExpansion() {
              document.querySelectorAll('.trade-tile').forEach(tile => {
                tile.addEventListener('click', () => {
                tile.classList.toggle('expanded');
                    });
                 });
        }
 
        function makeTilesEditable() {
    document.querySelectorAll(
        '.trade-tile.expanded .tile-details span, .trade-tile.expanded .tile-ticker'
    ).forEach(el => {
        el.setAttribute('contenteditable', 'true');

        el.addEventListener('blur', () => {
            const positionId = parseInt(el.closest('.trade-tile').dataset.positionId);
            const position = appState.positions.find(p => p.id === positionId);

            if (!position) return;

            // Match field by checking text content
            if (el.innerText.match(/Strike/)) {
                position.strike = parseFloat(el.innerText.replace(/[^\d.]/g, '')) || position.strike;
            } else if (el.innerText.match(/Exp/)) {
                position.expiry = el.innerText.replace(/Exp:\s*/i, '').trim();
            } else if (el.innerText.match(/Premium/)) {
                position.premium = parseFloat(el.innerText.replace(/[^\d.]/g, '')) || position.premium;
            } else if (el.classList.contains('tile-ticker')) {
                position.ticker = el.innerText.toUpperCase();
            }

            saveData();
            updateDashboard();
            loadActivityTiles();
        });
    });
}


// Call this after tiles are rendered
enableTileExpansion();

        function createTradeTile(position, totalPortfolioValue) {
            const tile = document.createElement('div');
            tile.className = `trade-tile ${position.side || 'buy'}-tile`;
            if (position.grayed) {
                tile.classList.add('grayed');
            }
            tile.draggable = !position.grayed;
            tile.dataset.positionId = position.id;
            
            // Calculate tile size based on portfolio percentage
            const positionValue = position.type === 'stock' 
                ? position.quantity * position.price 
                : position.quantity * position.premium * 100;
            const portfolioPercent = totalPortfolioValue > 0 ? (positionValue / totalPortfolioValue) * 100 : 0;
            
            // Set tile size (minimum 150px, max 300px)
            const tileSize = Math.max(150, Math.min(300, 150 + portfolioPercent * 3));
            tile.style.width = tileSize + 'px';
            tile.style.height = (tileSize * 0.8) + 'px';
            
            let tileContent = `
                <div class="tile-actions">
                    ${position.quantity > 1 ? `<button class="tile-action-btn" onclick="openSplitModal(${position.id})">✂</button>` : ''}
                    <button class="tile-action-btn" onclick="combineTiles(${position.id})">⊕</button>
                </div>
                <div class="tile-ticker">${position.ticker}</div>
            `;
            
            if (position.type === 'stock') {
                tileContent += `
                    <div class="tile-details">
                        <span>${position.quantity} shares</span>
                        <span>$${position.price.toFixed(2)}</span>
                    </div>
                    <div class="tile-details">
                        <span>${position.date}</span>
                        <span>Stock</span>
                    </div>
                `;
            } else {
                const optionTypeDisplay = position.type.replace('_', ' ').toUpperCase();
                tileContent += `
                    <div class="tile-details">
                        <span>${position.quantity} contracts</span>
                        <span>$${position.strike} Strike</span>
                    </div>
                    <div class="tile-details">
                        <span>${optionTypeDisplay}</span>
                        <span>Exp: ${position.expiry}</span>
                    </div>
                    <div class="tile-details">
                        <span>Premium: $${position.premium}</span>
                        <span>${position.date}</span>
                    </div>
                `;
            }
            // gray out and disable if countdown active
            if (position.countdown) {
                tile.classList.add('countdown');
                tileContent += `<div class="countdown-timer">${position.countdown}</div>`;
            }
            //gray out and disable if grayed
            if (position.grayed) {
                tileContent += `<button class="tile-delete-btn" onclick="deleteTile(${position.id})">✖</button>`;
           }


            tile.innerHTML = tileContent;
            return tile;
        }

        function deleteTile(positionId) {
         const index = appState.positions.findIndex(p => p.id === positionId);
         if (index > -1) {
        appState.positions.splice(index, 1); // remove from positions
        saveData();
        loadActivityTiles();
        updateDashboard();
        showAIMessage("Tile removed from Activity 🚮");
            }
        } 

        function enableDragAndDrop() {
            const tiles = document.querySelectorAll('.trade-tile:not(.grayed)');
            const buyColumn = document.querySelector('#buyTiles');
            const sellColumn = document.querySelector('#sellTiles');
            
            tiles.forEach(tile => {
                tile.addEventListener('dragstart', handleDragStart);
                tile.addEventListener('dragend', handleDragEnd);
            });
            
            [buyColumn, sellColumn].forEach(column => {
                if (column) {
                    column.addEventListener('dragover', handleDragOver);
                    column.addEventListener('drop', handleDrop);
                }
            });
        }

        function handleDragStart(e) {
            draggedTile = this;
            this.style.opacity = '0.5';
        }

        function handleDragEnd(e) {
            this.style.opacity = '';
        }

        function handleDragOver(e) {
            if (e.preventDefault) {
                e.preventDefault();
            }
            return false;
        }

        function handleDrop(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            
            if (draggedTile) {
                const positionId = parseInt(draggedTile.dataset.positionId);
                const position = appState.positions.find(p => p.id === positionId);
                
                if (!position) return;
                
                const targetColumn = e.currentTarget.id;
                
                // Handle the move based on position type and target
                if (targetColumn === 'sellTiles' && position.side !== 'sell') {
                    // Moving to sell - need sell price
                    currentSellTrade = position;
                    openSellPriceModal();
                } else if (targetColumn === 'buyTiles' && position.side === 'sell') {
                    // Closing a sold option position
                    if (position.type === 'sell_call' || position.type === 'sell_put') {
                        currentSellTrade = position;
                        openCloseOptionModal();
                    } else {
                        handleBuyBack(position);
                    }
                }
            }
            
            return false;
        }


        function openSellPriceModal() {
            document.getElementById('sellPriceModal').classList.add('active');
        }

        function closeSellModal() {
            document.getElementById('sellPriceModal').classList.remove('active');
            currentSellTrade = null;
        }

        function confirmSell() {
            if (!currentSellTrade) return;
            
            const sellPrice = parseFloat(document.getElementById('sellPrice').value);
            if (!sellPrice || sellPrice <= 0) {
                showAIMessage("Enter a valid sell price!");
                return;
            }
            
            // CHECK FOR LOCKED SHARES (NEW CODE)
            if (currentSellTrade.type === 'stock') {
                const ticker = currentSellTrade.ticker;
                const lockedQty = appState.lockedShares[ticker] || 0;
                const availableQty = currentSellTrade.quantity - lockedQty;
                
                if (availableQty <= 0) {
                    showAIMessage(`All ${currentSellTrade.quantity} shares are locked as collateral for sold calls!`);
                    closeSellModal();
                    return;
                }
                
                if (currentSellTrade.quantity > availableQty) {
                    showAIMessage(`You can only sell ${availableQty} shares. ${lockedQty} are locked as call collateral.`);
                    closeSellModal();
                    return;
                }
            }
            
            // Calculate P/L
            const costBasis = currentSellTrade.quantity * currentSellTrade.price;
            const saleProceeds = currentSellTrade.quantity * sellPrice;
            const pnl = saleProceeds - costBasis;
            
            // ... rest of function continues unchanged
            
            // Add proceeds to balance
            addToBalance(saleProceeds);
            
            // Record in ledger
            const ledgerEntry = {
                id: Date.now(),
                timestamp: new Date().toISOString(),
                action: 'sell',
                ticker: currentSellTrade.ticker,
                type: currentSellTrade.type,
                quantity: currentSellTrade.quantity,
                price: sellPrice,
                total: saleProceeds,
                pnl: pnl,
                balance: appState.cash + appState.marginAvailable
            };
            // Include option metadata
            if (currentSellTrade.type !== 'stock') {
            ledgerEntry.strike = currentSellTrade.strike;
            ledgerEntry.expiry = currentSellTrade.expiry;
            ledgerEntry.premium = sellPrice;
            }

            appState.ledger.push(ledgerEntry);
            
            // Update position
            currentSellTrade.side = 'sell';
            currentSellTrade.sellPrice = sellPrice;
            currentSellTrade.pnl = pnl;
            
            // Start countdown timer
            startTileCountdown(currentSellTrade);
            
            // Show AI message
            appState.tradeCount++;
            if (pnl > 0) {
                showAIMessage(`Nice profit take! +$${formatNumber(pnl)} secured 💰`);
            } else {
                showAIMessage(`Cut your losses. -$${formatNumber(Math.abs(pnl))}. Live to trade another day!`);
            }
            
            // Check for $10k daily milestone (NEW CODE)
            const today = new Date().toISOString().split('T')[0];
            const todayEntries = appState.ledger.filter(entry => 
                entry.timestamp && entry.timestamp.startsWith(today)
            );
            const dailyPnl = todayEntries.reduce((sum, entry) => sum + (entry.pnl || 0), 0);
            
            if (dailyPnl >= 10000) {
                triggerConfetti();
                showAIMessage("MASSIVE WIN! $10k+ day! You're crushing it! 🔥💰🚀");
            }
            
            closeSellModal();
            loadActivityTiles();
            enableTileExpansion();
            makeTilesEditable();
            saveData();
        }

        // Returns { [entryId]: avgCostAfterThisEntry } for STOCK entries
        function computeAvgCostMap(entriesAsc) {
            const result = {};
            const stateByTicker = new Map(); // ticker -> { qty, cost, lastAvg }

            for (const e of entriesAsc) {
                if (e.type === 'stock') {
                    const t = e.ticker;
                    if (!stateByTicker.has(t)) {
                        stateByTicker.set(t, { qty: 0, cost: 0, lastAvg: 0 });
                    }
                    const s = stateByTicker.get(t);
                    const qty = Number(e.quantity) || 0;
                    const price = Number(e.price) || 0;

                    // Before updating, get current avg
                    const currentAvg = s.qty > 0 ? s.cost / s.qty : s.lastAvg;

                    if ((e.action || '').toLowerCase() === 'buy') {
                        s.cost += qty * price;
                        s.qty  += qty;
                        if (s.qty > 0) {
                            s.lastAvg = s.cost / s.qty; // Update last known average
                        }
                    } else if ((e.action || '').toLowerCase() === 'sell') {
                        const reduceQty = Math.min(s.qty, qty);
                        s.cost -= currentAvg * reduceQty;
                        s.qty  -= reduceQty;
                        // lastAvg stays unchanged - preserves last known value
                    }

                    // Store either current average OR last known average
                    result[e.id] = s.qty > 0 ? s.cost / s.qty : s.lastAvg;
                }
            }

            return result;
        }


        // Returns { [entryId]: avgPremiumAfterThisEntry } for OPTION entries
        function computeAvgPremiumMap(entriesAsc) {
            const result = {};
            const stateByOption = new Map(); // key -> { qty, cost, lastAvg }

            for (const e of entriesAsc) {
                if (e.type !== 'stock' && e.strike && e.expiry) {
                    // Create unique key for this option position
                    const key = `${e.ticker}_${e.type}_${e.strike}_${e.expiry}`;
                    
                    if (!stateByOption.has(key)) {
                        stateByOption.set(key, { qty: 0, cost: 0, lastAvg: 0 });
                    }
                    const s = stateByOption.get(key);
                    const qty = Number(e.quantity) || 0;
                    const premium = Number(e.premium ?? e.price) || 0;

                    // Before updating, get current avg
                    const currentAvg = s.qty > 0 ? s.cost / s.qty : s.lastAvg;

                    if ((e.action || '').toLowerCase() === 'buy') {
                        s.cost += qty * premium;
                        s.qty  += qty;
                        if (s.qty > 0) {
                            s.lastAvg = s.cost / s.qty; // Update last known average
                        }
                    } else if ((e.action || '').toLowerCase() === 'sell' || (e.action || '').toLowerCase() === 'close') {
                        const reduceQty = Math.min(s.qty, qty);
                        s.cost -= currentAvg * reduceQty;
                        s.qty  -= reduceQty;
                        // lastAvg stays unchanged - preserves last known value
                    }

                    // Store either current average OR last known average
                    result[e.id] = s.qty > 0 ? s.cost / s.qty : s.lastAvg;
                }
            }

            return result;
        }

        function handleBuyBack(position) {
            // For options that were sold, buying back closes the position
            if (position.type === 'sell_call' || position.type === 'sell_put') {
                // Release locked collateral or shares
                if (position.type === 'sell_put') {
                    appState.lockedCollateral -= position.strike * position.quantity * 100;
                }
                
                // Mark as closed
                position.status = 'closed';
                position.side = 'buy';
                
                // Start countdown
                startTileCountdown(position);
                
                showAIMessage("Position closed! Collateral released 🔓");
            }
            
            loadActivityTiles();
            updateBalances();
            saveData();
        }

        function openCloseOptionModal() {
            document.getElementById('closeOptionModal').classList.add('active');
            // Show/hide close premium based on expiry
            document.getElementById('optionExpired').addEventListener('change', function() {
                const premiumGroup = document.getElementById('closePremiumGroup');
                premiumGroup.style.display = this.value === 'true' ? 'none' : 'block';
            });
        }

        function closeCloseOptionModal() {
            document.getElementById('closeOptionModal').classList.remove('active');
            document.getElementById('closePremium').value = '';
            document.getElementById('optionExercised').value = 'false';
            document.getElementById('optionExpired').value = 'false';
            currentSellTrade = null;
        }

        function confirmCloseOption() {
            if (!currentSellTrade) return;
            
            const exercised = document.getElementById('optionExercised').value === 'true';
            const expired = document.getElementById('optionExpired').value === 'true';
            const closePremium = expired ? 0 : parseFloat(document.getElementById('closePremium').value) || 0;
            
            const originalPremium = currentSellTrade.premium || currentSellTrade.price;
            const contracts = currentSellTrade.quantity;
            
            // Calculate P/L
            let pnl = 0;
            if (expired) {
                // Keep full premium as profit
                pnl = originalPremium * contracts * 100;
                showAIMessage(`Option expired worthless! +$${pnl.toFixed(2)} profit locked in! 💰`);
            } else {
                // Premium received minus premium paid to close
                pnl = (originalPremium - closePremium) * contracts * 100;
                if (pnl > 0) {
                    showAIMessage(`Closed for profit! +$${pnl.toFixed(2)} 🎯`);
                } else {
                    showAIMessage(`Closed at a loss. -$${Math.abs(pnl).toFixed(2)} 📉`);
                }
            }
            
            // Release collateral
            if (currentSellTrade.type === 'sell_call') {
                const ticker = currentSellTrade.ticker;
                if (!appState.lockedShares[ticker]) appState.lockedShares[ticker] = 0;
                appState.lockedShares[ticker] -= contracts * 100;
                if (appState.lockedShares[ticker] < 0) appState.lockedShares[ticker] = 0;
            } else if (currentSellTrade.type === 'sell_put') {
                const collateral = currentSellTrade.strike * contracts * 100;
                appState.lockedCollateral -= collateral;
                if (appState.lockedCollateral < 0) appState.lockedCollateral = 0;
            }
            
            // Add P/L to balance
            addToBalance(pnl);
            
            // Record in ledger
            appState.ledger.push({
                id: Date.now(),
                timestamp: new Date().toISOString(),
                action: 'close',
                ticker: currentSellTrade.ticker,
                type: currentSellTrade.type,
                strike: currentSellTrade.strike,
                expiry: currentSellTrade.expiry,
                quantity: contracts,
                price: closePremium,
                premium: closePremium,
                total: closePremium * contracts * 100,
                pnl: pnl,
                balance: appState.cash + appState.marginAvailable
            });
            
            // Mark as closed and start countdown
            currentSellTrade.status = 'closed';
            currentSellTrade.side = 'buy';
            startTileCountdown(currentSellTrade);
            
            closeCloseOptionModal();
            loadActivityTiles();
            updateBalances();
            updateDashboard();
            
            // Check for $10k daily milestone (NEW CODE)
            const today = new Date().toISOString().split('T')[0];
            const todayEntries = appState.ledger.filter(entry => 
                entry.timestamp && entry.timestamp.startsWith(today)
            );
            const dailyPnl = todayEntries.reduce((sum, entry) => sum + (entry.pnl || 0), 0);
            
            if (dailyPnl >= 10000) {
                triggerConfetti();
                showAIMessage("MASSIVE WIN! $10k+ day! You're crushing it! 🔥💰🚀");
            }
            
            saveData();
        }

        function startTileCountdown(position) {
            let countdown = 60;
            position.countdown = countdown;
            
            const timer = setInterval(() => {
                countdown--;
                position.countdown = countdown;
                
                if (countdown <= 0) {
                    clearInterval(timer);
                    position.grayed = true;
                    position.countdown = null;
                    loadActivityTiles();
                    saveData();
                } else {
                    // Update countdown display
                    const tile = document.querySelector(`[data-position-id="${position.id}"]`);
                    if (tile) {
                        const timerEl = tile.querySelector('.countdown-timer');
                        if (timerEl) {
                            timerEl.textContent = countdown;
                        }
                    }
                }
            }, 1000);
        }

        function openSplitModal(positionId) {
            const position = appState.positions.find(p => p.id === positionId);
            if (!position) return;
            
            currentSplitTrade = position;
            document.getElementById('splitInfo').textContent = 
                `Current position: ${position.quantity} ${position.type === 'stock' ? 'shares' : 'contracts'} of ${position.ticker}`;
            document.getElementById('splitModal').classList.add('active');
        }

        function closeSplitModal() {
            document.getElementById('splitModal').classList.remove('active');
            currentSplitTrade = null;
        }

        function confirmSplit() {
            if (!currentSplitTrade) return;
            
            const splitQty = parseInt(document.getElementById('splitQuantity').value);
            if (!splitQty || splitQty <= 0 || splitQty >= currentSplitTrade.quantity) {
                showAIMessage("Enter a valid split quantity!");
                return;
            }
            
            // Create new position with split quantity
            const newPosition = {
                ...currentSplitTrade,
                id: Date.now(),
                quantity: splitQty
            };
            
            // Reduce original position quantity
            currentSplitTrade.quantity -= splitQty;
            
            // Add new position
            appState.positions.push(newPosition);
            
            closeSplitModal();
            loadActivityTiles();
            saveData();
            
            showAIMessage("Position split successfully! 📄");
        }

        function combineTiles(positionId) {
            const position = appState.positions.find(p => p.id === positionId);
            if (!position) return;
            
            // Find compatible positions to combine
            const compatible = appState.positions.filter(p => 
                p.id !== positionId &&
                p.ticker === position.ticker &&
                p.type === position.type &&
                p.status === 'open' &&
                p.side === position.side &&
                (p.type === 'stock' || 
                 (p.strike === position.strike && p.expiry === position.expiry))
            );
            
            if (compatible.length === 0) {
                showAIMessage("No compatible positions to combine!");
                return;
            }
            
            // Combine positions
            let totalQuantity = position.quantity;

            if (position.type === 'stock') {
                // --- STOCKS: DCA on price ---
                let totalCost = position.quantity * position.price;

                compatible.forEach(p => {
                    totalQuantity += p.quantity;
                    totalCost += p.quantity * p.price;
                    const index = appState.positions.indexOf(p);
                    if (index > -1) appState.positions.splice(index, 1);
                });

                position.quantity = totalQuantity;
                position.price = totalCost / totalQuantity; // DCA price
            } else {
                // --- OPTIONS: DCA on premium (per contract) ---
                let totalPremiumCost = position.quantity * position.premium;

                compatible.forEach(p => {
                    totalQuantity += p.quantity;
                    totalPremiumCost += p.quantity * p.premium;
                    const index = appState.positions.indexOf(p);
                    if (index > -1) appState.positions.splice(index, 1);
                });

                position.quantity = totalQuantity;
                position.premium = totalPremiumCost / totalQuantity; // DCA premium
            }

            loadActivityTiles();
            saveData();
            
            showAIMessage(`Positions combined! New avg: $${(position.type === 'stock' ? position.price : position.premium).toFixed(2)} 📊`);

        }

        // Ledger Functions
        function updateLedger() {
            const tbody = document.getElementById('ledgerBody');
            tbody.innerHTML = '';
            
            // Sort ledger by timestamp (newest first)
            const sortedLedger = [...appState.ledger].sort((a, b) => 
                new Date(b.timestamp) - new Date(a.timestamp)
            );
            // Compute running average cost per stock entry (needs ascending order)
            const asc = [...appState.ledger].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            const avgMap = computeAvgCostMap(asc);
            const premiumMap = computeAvgPremiumMap(asc);  
            
            sortedLedger.forEach(entry => {
                const row = document.createElement('tr');
                const date = new Date(entry.timestamp);
                const timeStr = date.toLocaleString();
                
           row.innerHTML = `
            <td>${timeStr}</td>
            <td>${entry.action}</td>
            <td><strong>${entry.ticker}</strong></td>
            <td>${entry.type}</td>

            <!-- Strike/Expiry -->
            <td>${
                entry.type !== 'stock'
                    ? `${(Number(entry.strike) || 0).toFixed(2)} / ${entry.expiry || '-'}`
                    : '—'
                }</td>

            <td>${entry.quantity}</td>

            <!-- Avg Cost: stocks show DCA, options show per-contract premium -->
            <td>${
                entry.type === 'stock' && avgMap[entry.id] != null
                    ? (Number(avgMap[entry.id]) || 0).toFixed(2)
                    : entry.type !== 'stock' && entry.premium != null
                    ? (Number(entry.premium) || 0).toFixed(2)
                    : '—'
                }</td>

            <!-- Price (same as avg cost for options, per-share for stocks) -->
            <td>$${(
                entry.type !== 'stock'
                    ? (Number(entry.premium ?? entry.price) || 0)
                    : (Number(entry.price) || 0)
                ).toFixed(2)}</td>

            <td>$${(Number(entry.total) || 0).toFixed(2)}</td>

            <td class="${entry.pnl >= 0 ? 'pnl-positive' : 'pnl-negative'}">
                ${entry.pnl !== undefined ? (entry.pnl >= 0 ? '+' : '') + '$' + formatNumber(entry.pnl) : '-'}
            </td>

            <td>$${(Number(entry.balance) || 0).toFixed(2)}</td>
            `;
                tbody.appendChild(row);
            });
        }

        function filterLedger() {
            const tickerFilter = document.getElementById('tickerFilter').value.toUpperCase();
            const startDate = document.getElementById('startDateFilter').value;
            const endDate = document.getElementById('endDateFilter').value;
            const asc = [...filteredLedger].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            const avgMap = computeAvgCostMap(asc);

            let filteredLedger = [...appState.ledger];
            
            if (tickerFilter) {
                filteredLedger = filteredLedger.filter(entry => 
                    entry.ticker && entry.ticker.includes(tickerFilter)
                );
            }
            
            if (startDate) {
                filteredLedger = filteredLedger.filter(entry => 
                    entry.timestamp >= startDate
                );
            }
            
            if (endDate) {
                const endDateTime = new Date(endDate);
                endDateTime.setDate(endDateTime.getDate() + 1);
                filteredLedger = filteredLedger.filter(entry => 
                    entry.timestamp < endDateTime.toISOString()
                );
            }
            
            // Update ledger display with filtered results
            const tbody = document.getElementById('ledgerBody');
            tbody.innerHTML = '';
            
            filteredLedger.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            
            filteredLedger.forEach(entry => {
                const row = document.createElement('tr');
                const date = new Date(entry.timestamp);
                const timeStr = date.toLocaleString();
                
                row.innerHTML = `
                    <td>${timeStr}</td>
                    <td>${entry.action.toUpperCase()}</td>
                    <td><strong>${entry.ticker}</strong></td>
                    <td>${entry.type}</td>
                    <td>${entry.quantity}</td>
                    <td>$${entry.price.toFixed(2)}</td>
                    <td>$${formatInt(entry.total)}</td>
                    <td class="${entry.pnl > 0 ? 'pnl-positive' : entry.pnl < 0 ? 'pnl-negative' : 'pnl-zero'}">
                        ${entry.pnl !== undefined
                            ? (entry.pnl > 0 ? '+' : entry.pnl < 0 ? '-' : '') + '$' + Math.abs(Number(entry.pnl) || 0).toFixed(2)
                            : '-'}
                    </td>
                    <td>$${formatInt(entry.balance)}</td>

                `;
                tbody.appendChild(row);
            });
        }

        function clearLedgerFilters() {
            document.getElementById('tickerFilter').value = '';
            document.getElementById('startDateFilter').value = '';
            document.getElementById('endDateFilter').value = '';
            updateLedger();
        }

        // Analytics Functions
        function updateAnalytics() {
            generateCalendar();
            drawRadarChart();
            drawPieChart();
            drawBalanceChart();
            drawPnLChart();
            calculateMetrics();
        }

        function changeMonth(direction) {
            appState.currentMonth += direction;
            
            if (appState.currentMonth < 0) {
                appState.currentMonth = 11;
                appState.currentYear--;
            } else if (appState.currentMonth > 11) {
                appState.currentMonth = 0;
                appState.currentYear++;
            }
            
            generateCalendar();
        }

        function generateCalendar() {
            const calendar = document.getElementById('tradingCalendar');
            const monthEl = document.getElementById('calendarMonth');
            
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 
                              'July', 'August', 'September', 'October', 'November', 'December'];
            
            monthEl.textContent = `${monthNames[appState.currentMonth]} ${appState.currentYear}`;
            
            calendar.innerHTML = '';
            
            const firstDay = new Date(appState.currentYear, appState.currentMonth, 1);
            const lastDay = new Date(appState.currentYear, appState.currentMonth + 1, 0);
            
            // Get day of week for first day (0=Sun, 1=Mon, etc.)
            let firstDayOfWeek = firstDay.getDay();
            // Convert to Mon=0, Tue=1, ..., Fri=4, Sat=5, Sun=6
            firstDayOfWeek = firstDayOfWeek === 0 ? 6 : firstDayOfWeek - 1;
            
            // Calculate start date (may be from previous month)
            const startDate = new Date(firstDay);
            startDate.setDate(startDate.getDate() - firstDayOfWeek);
            
            // Calculate end date (ensure we have complete weeks, may go into next month)
            const endDate = new Date(lastDay);
            const lastDayOfWeek = lastDay.getDay();
            const daysToAdd = lastDayOfWeek === 0 ? 0 : 5 - (lastDayOfWeek === 0 ? 6 : lastDayOfWeek - 1);
            endDate.setDate(endDate.getDate() + daysToAdd);
            
            let currentDate = new Date(startDate);
            let weekPnl = 0;
            let weekDayCount = 0;
            
            while (currentDate <= endDate) {
                const dayOfWeek = currentDate.getDay();
                
                // Skip weekends
                if (dayOfWeek === 0 || dayOfWeek === 6) {
                    currentDate.setDate(currentDate.getDate() + 1);
                    continue;
                }
                
                const dateStr = currentDate.toISOString().split('T')[0];
                const day = currentDate.getDate();
                const isCurrentMonth = currentDate.getMonth() === appState.currentMonth;
                
                // Get P/L for this day from ledger
                const dayEntries = appState.ledger.filter(entry => 
                    entry.timestamp && entry.timestamp.startsWith(dateStr)
                );
                const dayPnl = dayEntries.reduce((sum, entry) => sum + (entry.pnl || 0), 0);
                
                const dayDiv = document.createElement('div');
                dayDiv.className = 'calendar-day';
                if (dayPnl > 0) {
                    dayDiv.classList.add('profit');
                } else if (dayPnl < 0) {
                    dayDiv.classList.add('loss');
                }
                
                // Dim dates from other months
                if (!isCurrentMonth) {
                    dayDiv.style.opacity = '0.4';
                }
                
                dayDiv.innerHTML = `
                    <div class="calendar-day-number">${day}</div>
                    ${dayPnl !== 0 ? `<div class="calendar-day-pnl">${dayPnl > 0 ? '+' : ''}$${Math.abs(dayPnl).toFixed(0)}</div>` : ''}
                `;
                
                calendar.appendChild(dayDiv);
                
                weekPnl += dayPnl;
                weekDayCount++;
                
                // Add weekly total on Friday (dayOfWeek === 5) or at end
                if (dayOfWeek === 5 || currentDate >= endDate) {
                    const weekTotal = document.createElement('div');
                    weekTotal.className = 'calendar-week-total';
                    if (weekPnl > 0) weekTotal.classList.add('positive');
                    if (weekPnl < 0) weekTotal.classList.add('negative');
                    weekTotal.textContent = weekPnl !== 0 ? `${weekPnl > 0 ? '+' : ''}$${Math.abs(weekPnl).toFixed(0)}` : '$0';
                    calendar.appendChild(weekTotal);
                    
                    weekPnl = 0;
                    weekDayCount = 0;
                }
                
                currentDate.setDate(currentDate.getDate() + 1);
            }
        }

        function drawRadarChart() {
            const canvas = document.getElementById('radarChart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = 120;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Calculate actual metrics
            const completedTrades = appState.ledger.filter(e => e.action === 'sell' && e.pnl !== undefined);
            const winningTrades = completedTrades.filter(t => t.pnl > 0);
            const winRate = completedTrades.length > 0 ? winningTrades.length / completedTrades.length : 0.5;
            
            // Metrics (normalized to 0-1)
            const metrics = [
                { label: 'Win Rate', value: winRate },
                { label: 'Risk/Reward', value: 0.7 },
                { label: 'Consistency', value: 0.6 },
                { label: 'Hold Time', value: 0.5 },
                { label: 'Profit Factor', value: 0.75 },
                { label: 'Max DD', value: 0.4 }
            ];
            
            // Draw web background
            ctx.strokeStyle = '#2a2a2a';
            ctx.lineWidth = 1;
            
            for (let i = 1; i <= 5; i++) {
                ctx.beginPath();
                for (let j = 0; j < metrics.length; j++) {
                    const angle = (Math.PI * 2 * j) / metrics.length - Math.PI / 2;
                    const x = centerX + Math.cos(angle) * (radius * (i / 5));
                    const y = centerY + Math.sin(angle) * (radius * (i / 5));
                    
                    if (j === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.closePath();
                ctx.stroke();
            }
            
            // Draw axes
            ctx.strokeStyle = '#2a2a2a';
            metrics.forEach((metric, i) => {
                const angle = (Math.PI * 2 * i) / metrics.length - Math.PI / 2;
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(
                    centerX + Math.cos(angle) * radius,
                    centerY + Math.sin(angle) * radius
                );
                ctx.stroke();
            });
            
            // Draw data
            ctx.strokeStyle = '#00ff88';
            ctx.fillStyle = 'rgba(0, 255, 136, 0.2)';
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            metrics.forEach((metric, i) => {
                const angle = (Math.PI * 2 * i) / metrics.length - Math.PI / 2;
                const x = centerX + Math.cos(angle) * (radius * metric.value);
                const y = centerY + Math.sin(angle) * (radius * metric.value);
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Draw labels
            ctx.fillStyle = '#a0a0a0';
            ctx.font = '12px Arial';
            ctx.textAlign = 'center';
            
            metrics.forEach((metric, i) => {
                const angle = (Math.PI * 2 * i) / metrics.length - Math.PI / 2;
                const labelRadius = radius + 20;
                const x = centerX + Math.cos(angle) * labelRadius;
                const y = centerY + Math.sin(angle) * labelRadius;
                
                // Adjust text baseline based on position
                if (i === 0) ctx.textBaseline = 'bottom';
                else if (i === 3) ctx.textBaseline = 'top';
                else ctx.textBaseline = 'middle';
                
                ctx.fillText(metric.label, x, y);
            });
        }

        function drawPieChart() {
            const canvas = document.getElementById('pieChart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = 100;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Calculate portfolio allocation
            const allocation = {};
            let totalValue = 0;
            
            appState.positions.filter(p => p.status === 'open').forEach(position => {
                const value = position.type === 'stock' 
                    ? position.quantity * position.price 
                    : position.quantity * position.premium * 100;
                
                if (!allocation[position.ticker]) {
                    allocation[position.ticker] = 0;
                }
                allocation[position.ticker] += value;
                totalValue += value;
            });
            
            if (totalValue === 0) {
                // No positions, draw empty state
                ctx.fillStyle = '#a0a0a0';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('No positions', centerX, centerY);
                return;
            }
            
            // Convert to percentages and prepare data
            const data = Object.entries(allocation)
                .map(([ticker, value]) => ({
                    ticker: ticker,
                    value: (value / totalValue) * 100,
                    amount: value
                }))
                .sort((a, b) => b.value - a.value)
                .slice(0, 4); // Top 4 holdings
            
            // Add "Other" category if needed
            const topTotal = data.reduce((sum, d) => sum + d.value, 0);
            if (topTotal < 100) {
                data.push({
                    ticker: 'Other',
                    value: 100 - topTotal,
                    amount: totalValue * (100 - topTotal) / 100
                });
            }
            
            const colors = ['#00ff88', '#00a8ff', '#ff3366', '#ffd700', '#ff6b6b'];
            
            // Draw pie slices
            let currentAngle = -Math.PI / 2;
            
            data.forEach((segment, index) => {
                if (segment.value <= 0) return;
                
                const sliceAngle = (segment.value / 100) * Math.PI * 2;
                
                // Draw slice
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + sliceAngle);
                ctx.closePath();
                ctx.fillStyle = colors[index % colors.length];
                ctx.fill();
                
                // Draw label
                const labelAngle = currentAngle + sliceAngle / 2;
                const labelX = centerX + Math.cos(labelAngle) * (radius + 30);
                const labelY = centerY + Math.sin(labelAngle) * (radius + 30);
                
                ctx.fillStyle = '#a0a0a0';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`${segment.ticker}`, labelX, labelY);
                ctx.fillText(`${segment.value.toFixed(1)}%`, labelX, labelY + 15);
                
                currentAngle += sliceAngle;
            });
        }

        function drawBalanceChart() {
            const canvas = document.getElementById('balanceChart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const padding = 60;
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // Get selected range
            const rangeSelect = document.getElementById('balanceChartRange');
            const rangeDays = rangeSelect ? rangeSelect.value : '30';
            
            // Filter ledger by date range
            let filteredLedger = [...appState.ledger].sort((a, b) => 
                new Date(a.timestamp) - new Date(b.timestamp)
            );
            
            if (rangeDays !== 'all') {
                const cutoffDate = new Date(Date.now() - parseInt(rangeDays) * 86400000);
                filteredLedger = filteredLedger.filter(e => new Date(e.timestamp) >= cutoffDate);
            }
            
            if (filteredLedger.length === 0) {
                ctx.fillStyle = '#a0a0a0';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('No data for selected range', width / 2, height / 2);
                return;
            }
            
            // Build data points
            const dataPoints = filteredLedger.map(entry => ({
                date: new Date(entry.timestamp),
                balance: entry.balance || 0
            }));
            
            // Add starting point
            if (dataPoints.length > 0) {
                const startBalance = dataPoints[0].balance - (filteredLedger[0].pnl || 0);
                dataPoints.unshift({
                    date: new Date(dataPoints[0].date.getTime() - 86400000),
                    balance: startBalance
                });
            }
            
            const minBalance = Math.min(...dataPoints.map(d => d.balance));
            const maxBalance = Math.max(...dataPoints.map(d => d.balance));
            const balanceRange = maxBalance - minBalance || 1;
            
            // Draw axes
            ctx.strokeStyle = '#2a2a2a';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.lineTo(width - padding, height - padding);
            ctx.stroke();
            
            // Draw grid lines
            ctx.strokeStyle = '#1a1a1a';
            for (let i = 1; i <= 4; i++) {
                const y = padding + (height - 2 * padding) * i / 5;
                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(width - padding, y);
                ctx.stroke();
            }
            
            // Get chart type and draw accordingly
            const chartTypeSelect = document.getElementById('balanceChartType');
            const chartType = chartTypeSelect ? chartTypeSelect.value : 'line';
            
            if (chartType === 'bar') {
                // Draw bars
                const barWidth = Math.max(2, (width - 2 * padding) / dataPoints.length * 0.8);
                ctx.fillStyle = '#00ff88';
                
                dataPoints.forEach((point, i) => {
                    const x = padding + (width - 2 * padding) * i / (dataPoints.length - 1);
                    const barHeight = ((point.balance - minBalance) / balanceRange) * (height - 2 * padding);
                    const y = height - padding - barHeight;
                    ctx.fillRect(x - barWidth / 2, y, barWidth, barHeight);
                });
            } else {
                // Draw line
                ctx.strokeStyle = '#00ff88';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                dataPoints.forEach((point, i) => {
                    const x = padding + (width - 2 * padding) * i / (dataPoints.length - 1);
                    const y = height - padding - ((point.balance - minBalance) / balanceRange) * (height - 2 * padding);
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();
            }
            
            // Draw labels
            ctx.fillStyle = '#a0a0a0';
            ctx.font = '12px Arial';
            ctx.textAlign = 'right';
            
            // Y-axis labels
            for (let i = 0; i <= 4; i++) {
                const value = minBalance + (balanceRange * i / 4);
                const y = height - padding - (height - 2 * padding) * i / 4;
                ctx.fillText('$' + (value / 1000).toFixed(0) + 'K', padding - 10, y + 5);
            }
            
            // X-axis labels
            ctx.textAlign = 'center';
            const showEvery = Math.max(1, Math.ceil(dataPoints.length / 6));
            dataPoints.forEach((point, i) => {
                if (i % showEvery === 0 || i === dataPoints.length - 1) {
                    const x = padding + (width - 2 * padding) * i / (dataPoints.length - 1);
                    const dateStr = point.date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                    ctx.fillText(dateStr, x, height - padding + 20);
                }
            });
        }
        
        function updateBalanceChart() {
            drawBalanceChart();
        }

        function drawPnLChart() {
            const canvas = document.getElementById('pnlChart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const padding = 60;
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // Get selected range
            const rangeSelect = document.getElementById('pnlChartRange');
            const rangeDays = rangeSelect ? rangeSelect.value : '30';
            
            // Get daily P/L from ledger
            const dailyPnL = {};
            appState.ledger.forEach(entry => {
                if (entry.pnl !== undefined) {
                    const dateStr = entry.timestamp.split('T')[0];
                    dailyPnL[dateStr] = (dailyPnL[dateStr] || 0) + entry.pnl;
                }
            });
            
            let dates = Object.keys(dailyPnL).sort();
            
            // Filter by range
            if (rangeDays !== 'all') {
                const cutoffDate = new Date(Date.now() - parseInt(rangeDays) * 86400000);
                const cutoffStr = cutoffDate.toISOString().split('T')[0];
                dates = dates.filter(d => d >= cutoffStr);
            }
            
            if (dates.length === 0) {
                ctx.fillStyle = '#a0a0a0';
                ctx.font = '14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('No P/L data for selected range', width / 2, height / 2);
                return;
            }
            
            const dataPoints = dates.map(date => ({
                date: new Date(date),
                pnl: dailyPnL[date]
            }));
            
            const maxPnl = Math.max(...dataPoints.map(d => Math.abs(d.pnl)), 1000);
            
            // Draw axes
            ctx.strokeStyle = '#2a2a2a';
            ctx.lineWidth = 1;
            const centerY = height / 2;
            ctx.beginPath();
            ctx.moveTo(padding, padding);
            ctx.lineTo(padding, height - padding);
            ctx.moveTo(padding, centerY);
            ctx.lineTo(width - padding, centerY);
            ctx.stroke();
            
            // Get chart type and draw accordingly
            const chartTypeSelect = document.getElementById('pnlChartType');
            const chartType = chartTypeSelect ? chartTypeSelect.value : 'bar';
            
            if (chartType === 'bar') {
                // Draw bars
                const barWidth = Math.max(2, (width - 2 * padding) / dataPoints.length * 0.8);
                
                dataPoints.forEach((point, i) => {
                    const x = padding + (width - 2 * padding) * (i + 0.5) / dataPoints.length;
                    const barHeight = Math.abs(point.pnl / maxPnl) * (height / 2 - padding);
                    
                    if (point.pnl >= 0) {
                        ctx.fillStyle = '#00ff88';
                        ctx.fillRect(x - barWidth / 2, centerY - barHeight, barWidth, barHeight);
                    } else {
                        ctx.fillStyle = '#ff3366';
                        ctx.fillRect(x - barWidth / 2, centerY, barWidth, barHeight);
                    }
                });
            } else {
                // Draw line
                ctx.strokeStyle = '#00a8ff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                dataPoints.forEach((point, i) => {
                    const x = padding + (width - 2 * padding) * (i + 0.5) / dataPoints.length;
                    const y = centerY - (point.pnl / maxPnl) * (height / 2 - padding);
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.stroke();
                
                // Draw points
                ctx.fillStyle = '#00a8ff';
                dataPoints.forEach((point, i) => {
                    const x = padding + (width - 2 * padding) * (i + 0.5) / dataPoints.length;
                    const y = centerY - (point.pnl / maxPnl) * (height / 2 - padding);
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                });
            }
            
            // Draw labels
            ctx.fillStyle = '#a0a0a0';
            ctx.font = '12px Arial';
            ctx.textAlign = 'right';
            
            // Y-axis labels
            ctx.fillText('+$' + (maxPnl / 1000).toFixed(0) + 'K', padding - 10, padding + 15);
            ctx.fillText('$0', padding - 10, centerY + 5);
            ctx.fillText('-$' + (maxPnl / 1000).toFixed(0) + 'K', padding - 10, height - padding + 5);
            
            // X-axis labels
            ctx.textAlign = 'center';
            const showEvery = Math.max(1, Math.ceil(dataPoints.length / 6));
            dataPoints.forEach((point, i) => {
                if (i % showEvery === 0 || i === dataPoints.length - 1) {
                    const x = padding + (width - 2 * padding) * (i + 0.5) / dataPoints.length;
                    const dateStr = point.date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                    ctx.fillText(dateStr, x, height - padding + 20);
                }
            });
        }
        
        function updatePnLChart() {
            drawPnLChart();
        }

        function calculateMetrics() {
            const completedTrades = appState.ledger.filter(e => e.action === 'sell' && e.pnl !== undefined);
            const winningTrades = completedTrades.filter(t => t.pnl > 0);
            
            // Profit Factor
            const profits = completedTrades.filter(t => t.pnl > 0).reduce((sum, t) => sum + t.pnl, 0);
            const losses = Math.abs(completedTrades.filter(t => t.pnl < 0).reduce((sum, t) => sum + t.pnl, 0));
            const profitFactor = losses > 0 ? profits / losses : profits > 0 ? 999 : 0;
            document.getElementById('profitFactor').textContent = profitFactor.toFixed(2);
            
            // YTD Profit
            const now = new Date();
            const yearStart = new Date(now.getFullYear(), 0, 1);
            const ytdEntries = appState.ledger.filter(e => 
                e.pnl !== undefined && new Date(e.timestamp) >= yearStart
            );
            const ytdProfit = ytdEntries.reduce((sum, e) => sum + e.pnl, 0);
            const ytdEl = document.getElementById('ytdProfit');
            ytdEl.textContent = (ytdProfit >= 0 ? '+' : '') + '$' + formatInt(Math.abs(ytdProfit));
            ytdEl.style.color = ytdProfit >= 0 ? 'var(--accent-green)' : 'var(--accent-red)';
            
            // 30-Day Profit
            const date30 = new Date(now.getTime() - 30 * 86400000);
            const entries30d = appState.ledger.filter(e => 
                e.pnl !== undefined && new Date(e.timestamp) >= date30
            );
            const profit30d = entries30d.reduce((sum, e) => sum + e.pnl, 0);
            const p30El = document.getElementById('profit30d');
            p30El.textContent = (profit30d >= 0 ? '+' : '') + '$' + formatInt(Math.abs(profit30d));
            p30El.style.color = profit30d >= 0 ? 'var(--accent-green)' : 'var(--accent-red)';
            
            // 7-Day Profit
            const date7 = new Date(now.getTime() - 7 * 86400000);
            const entries7d = appState.ledger.filter(e => 
                e.pnl !== undefined && new Date(e.timestamp) >= date7
            );
            const profit7d = entries7d.reduce((sum, e) => sum + e.pnl, 0);
            const p7El = document.getElementById('profit7d');
            p7El.textContent = (profit7d >= 0 ? '+' : '') + '$' + formatInt(Math.abs(profit7d));
            p7El.style.color = profit7d >= 0 ? 'var(--accent-green)' : 'var(--accent-red)';
            
            // Max Drawdown
            let maxDrawdown = 0;
            let peak = appState.settings.startingCash;
            let runningBalance = appState.settings.startingCash;
            
            appState.ledger.forEach(entry => {
                runningBalance += entry.pnl || 0;
                if (runningBalance > peak) peak = runningBalance;
                const drawdown = ((peak - runningBalance) / peak) * 100;
                if (drawdown > maxDrawdown) maxDrawdown = drawdown;
            });
            document.getElementById('maxDrawdown').textContent = maxDrawdown.toFixed(1) + '%';
            
            // Avg Hold Time
            let avgHoldDays = 0;
            if (completedTrades.length > 0) {
                avgHoldDays = Math.floor(Math.random() * 30) + 5;
            }
            document.getElementById('avgHoldTime').textContent = avgHoldDays + ' days';
            
            // Risk/Reward
            const avgWin = profits / Math.max(winningTrades.length, 1);
            const avgLoss = losses / Math.max(completedTrades.length - winningTrades.length, 1);
            const riskReward = avgLoss > 0 ? avgWin / avgLoss : 0;
            document.getElementById('riskReward').textContent = riskReward.toFixed(2);
        }

        // Margin Simulator Functions
        function updateSimulator() {
            const slider = document.getElementById('marketDropSlider');
            slider.addEventListener('input', simulateMarketDrop);
            simulateMarketDrop();
        }

        function simulateMarketDrop() {
            const dropPercent = parseInt(document.getElementById('marketDropSlider').value);
            document.getElementById('dropValue').textContent = dropPercent + '%';
            
            // Calculate portfolio value after drop
            let portfolioValue = 0;
            appState.positions.filter(p => p.status === 'open').forEach(position => {
                if (position.type === 'stock') {
                    const adjustedPrice = position.price * (1 - dropPercent / 100);
                    portfolioValue += position.quantity * adjustedPrice;
                }
            });
            
            const equity = portfolioValue - appState.marginUsed;
            const marginCallLevel = appState.marginUsed * 0.3; // 30% maintenance requirement
            
            document.getElementById('simPortfolioValue').textContent = '$' + formatInt(portfolioValue);
            document.getElementById('simEquity').textContent = '$' + formatInt(equity);
            document.getElementById('simMarginUsed').textContent = '$' + formatInt(appState.marginUsed);

            // Check for margin call
            const warningBox = document.getElementById('marginWarning');
            if (equity < marginCallLevel && appState.marginUsed > 0) {
                warningBox.classList.add('active');
                const cashNeeded = marginCallLevel - equity;
                document.getElementById('cashNeeded').textContent = '$' + formatInt(cashNeeded);
            } else {
                warningBox.classList.remove('active');
            }
            
            // Options impact
            updateOptionsImpact(dropPercent);
        }

        function updateOptionsImpact(dropPercent) {
            const container = document.getElementById('optionsImpact');
            const optionPositions = appState.positions.filter(p => 
                p.type !== 'stock' && p.status === 'open'
            );
            
            if (optionPositions.length === 0) {
                container.innerHTML = '<p style="color: var(--text-secondary);">No options positions to simulate</p>';
                return;
            }
            
            let html = '<div style="padding: 10px;">';
            optionPositions.forEach(option => {
                // Simplified options pricing impact
                let impactMultiplier = 1;
                if (option.type.includes('call')) {
                    impactMultiplier = 1 - (dropPercent / 100) * 2; // Calls lose value faster
                } else if (option.type.includes('put')) {
                    impactMultiplier = 1 + (dropPercent / 100) * 1.5; // Puts gain value
                }
                
                const newPremium = option.premium * impactMultiplier;
                const change = ((newPremium - option.premium) / option.premium) * 100;
                
                html += `
                    <div style="margin-bottom: 15px; padding: 10px; background: var(--bg-secondary); border-radius: 6px;">
                        <strong>${option.ticker} ${option.type.replace('_', ' ').toUpperCase()}</strong><br>
                        Strike: ${option.strike} | Exp: ${option.expiry}<br>
                        Premium: ${option.premium.toFixed(2)} → ${newPremium.toFixed(2)}
                        <span style="color: ${change >= 0 ? 'var(--accent-green)' : 'var(--accent-red)'}">
                            (${change >= 0 ? '+' : ''}${change.toFixed(1)}%)
                        </span>
                    </div>
                `;
            });
            html += '</div>';
            container.innerHTML = html;
        }

        // Trade Modal Functions
        function openTradeModal() {
            document.getElementById('tradeModal').classList.add('active');
            document.getElementById('tradeDate').value = new Date().toISOString().split('T')[0];
        }

        function closeModal() {
            document.getElementById('tradeModal').classList.remove('active');
        }

        function updateTradeForm() {
            const tradeType = document.getElementById('tradeType').value;
            const optionFields = document.getElementById('optionFields');
            
            if (tradeType !== 'stock') {
                optionFields.style.display = 'block';
            } else {
                optionFields.style.display = 'none';
            }
        }

        function saveTrade() {
            const date = document.getElementById('tradeDate').value;
            const ticker = document.getElementById('tradeTicker').value.toUpperCase();
            const type = document.getElementById('tradeType').value;
            const quantity = parseInt(document.getElementById('tradeQuantity').value);
            const price = parseFloat(document.getElementById('tradePrice').value);
            
            if (!date || !ticker || !quantity || !price) {
                showAIMessage("Please fill in all required fields!");
                return;
            }
            
            // Check buying power
            let totalCost = 0;
            if (type === 'stock') {
                totalCost = quantity * price;
            } else if (type.startsWith('buy')) {
                totalCost = quantity * price * 100; // Options premium
            }
            
            if (totalCost > (appState.cash + appState.marginAvailable)) {
                showAIMessage("Insufficient buying power! 💸");
                return;
            }
            
            // Create position
            const position = {
                id: Date.now(),
                date: date,
                ticker: ticker,
                type: type,
                quantity: quantity,
                price: price,
                status: 'open',
                side: type.startsWith('sell') ? 'sell' : 'buy'
            };
            
            // Handle options-specific fields
            if (type !== 'stock') {
                position.strike = parseFloat(document.getElementById('strikePrice').value);
                position.expiry = document.getElementById('expiryDate').value;
                position.premium = price;
                
                if (!position.strike || !position.expiry) {
                    showAIMessage("Please fill in strike price and expiry date for options!");
                    return;
                }
                
                // Handle collateral for sold options
                if (type === 'sell_put') {
                    const collateralNeeded = position.strike * quantity * 100;
                    if (collateralNeeded > appState.cash) {
                        showAIMessage("Insufficient cash for collateral!");
                        return;
                    }
                    appState.lockedCollateral += collateralNeeded;
                    appState.cash -= collateralNeeded;
                
                    } else if (type === 'sell_call') {
                    // Check if user has enough shares
                    const stockHoldings = appState.positions.filter(p => 
                        p.ticker === ticker && p.type === 'stock' && p.status === 'open'
                    ).reduce((sum, p) => sum + p.quantity, 0);
                    
                    const lockedQty = appState.lockedShares[ticker] || 0;
                    const availableShares = stockHoldings - lockedQty;
                    
                    if (availableShares < quantity * 100) {
                        showAIMessage(`Not enough shares! You have ${stockHoldings} total, ${lockedQty} locked, ${availableShares} available.`);
                        return;
                    }
                    
                    // Lock the shares
                    if (!appState.lockedShares[ticker]) appState.lockedShares[ticker] = 0;
                    appState.lockedShares[ticker] += quantity * 100;
                    
                    // Add premium to cash
                    addToBalance(quantity * price * 100);
                }
            }
            
            // Deduct cost if buying
            if (!type.startsWith('sell')) {
                deductFromBalance(totalCost);
            }
            
            // Add to positions
            appState.positions.push(position);
            
            // Record in ledger
            const ledgerEntry = {
                id: Date.now(),
                timestamp: new Date().toISOString(),
                action: type.startsWith('sell') ? 'sell' : 'buy',
                ticker: ticker,
                type: type,
                quantity: quantity,
                price: price,
                total: totalCost,
                balance: appState.cash + appState.marginAvailable
            };
            // Carry strike/expiry/premium for options into the ledger
                if (type !== 'stock') {
                ledgerEntry.strike = position.strike;
                ledgerEntry.expiry = position.expiry; // ISO yyyy-mm-dd is fine
                ledgerEntry.premium = price;          // per contract
                }

            appState.ledger.push(ledgerEntry);
            
            // Update trade count
            appState.tradeCount++;
            
            // Show AI message based on trade count
            if (appState.tradeCount >= 5 && appState.tradeCount % 5 === 0) {
                const messages = [
                    "You're on fire! 🔥 Keep those trades coming!",
                    "Trading machine activated! 🤖",
                    "Diamond hands or paper hands? Time will tell! 💎",
                    "The market gods are watching... 👀",
                    "Risk it for the biscuit! 🍪"
                ];
                showAIMessage(messages[Math.floor(Math.random() * messages.length)]);
            }
            
            closeModal();
            updateDashboard();
            loadActivityTiles();
            updateBalances();
            saveData();
        }

        // AI Advisor Functions
        function showAIMessage(message) {
            const popup = document.getElementById('aiPopup');
            const messageEl = document.getElementById('aiMessage');
            
            messageEl.textContent = message;
            popup.classList.add('active');
            
            setTimeout(() => {
                popup.classList.remove('active');
            }, 5000);
        }

        // Confetti Animation
        function triggerConfetti() {
            const colors = ['#00ff88', '#00a8ff', '#ff3366', '#ffd700'];
            
            for (let i = 0; i < 100; i++) {
                setTimeout(() => {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.left = Math.random() * window.innerWidth + 'px';
                    confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    document.body.appendChild(confetti);
                    
                    setTimeout(() => {
                        confetti.remove();
                    }, 5000);
                }, i * 30);
            }
        }

        // Settings Functions
        function saveAccountSettings() {
            const startingCash = parseFloat(document.getElementById('startingCash').value);
            const marginLimit = parseFloat(document.getElementById('marginLimit').value);
            
            if (!startingCash || !marginLimit) {
                showAIMessage("Enter valid amounts!");
                return;
            }
            
            appState.settings.startingCash = startingCash;
            appState.settings.marginLimit = marginLimit;
            appState.cash = startingCash;
            appState.marginAvailable = marginLimit;
            
            updateBalances();
            saveData();
            showAIMessage("Settings saved! 💾");
        }

        // Demo Data Generation
        function toggleDemoData() {
            const isEnabled = document.getElementById('demoToggle').checked;
            
            if (isEnabled) {
                generateDemoData();
                showAIMessage("Demo data loaded! 30 days of trading history 📊");
            } else {
                // Clear all data
                appState.positions = [];
                appState.ledger = [];
                appState.cash = appState.settings.startingCash;
                appState.marginAvailable = appState.settings.marginLimit;
                appState.marginUsed = 0;
                appState.lockedCollateral = 0;
                
                updateDashboard();
                updateBalances();
                saveData();
                showAIMessage("Demo data cleared!");
            }
        }

        function generateDemoData() {
            const tickers = ['TSLA', 'NVDA', 'AAPL', 'SPY'];
            const today = new Date();
            
            // Clear existing data
            appState.positions = [];
            appState.ledger = [];
            appState.cash = appState.settings.startingCash;
            appState.marginAvailable = appState.settings.marginLimit;
            
            // Generate 30 days of trades
            for (let i = 29; i >= 0; i--) {
                const date = new Date(today);
                date.setDate(date.getDate() - i);
                const dateStr = date.toISOString().split('T')[0];
                
                // Skip weekends
                if (date.getDay() === 0 || date.getDay() === 6) continue;
                
                // Generate 1-3 trades per day
                const tradesPerDay = Math.floor(Math.random() * 3) + 1;
                
                for (let j = 0; j < tradesPerDay; j++) {
                    const ticker = tickers[Math.floor(Math.random() * tickers.length)];
                    const isOption = Math.random() > 0.6;
                    
                    if (isOption) {
                        // Generate option trade
                        const optionTypes = ['buy_call', 'buy_put'];
                        const type = optionTypes[Math.floor(Math.random() * optionTypes.length)];
                        const strike = Math.round((200 + Math.random() * 300) / 5) * 5;
                        const premium = 2 + Math.random() * 20;
                        const quantity = Math.floor(Math.random() * 5) + 1;
                        
                        const expiry = new Date(date);
                        expiry.setDate(expiry.getDate() + 30);
                        
                        const cost = quantity * premium * 100;
                        if (cost <= (appState.cash + appState.marginAvailable)) {
                            const position = {
                                id: Date.now() + Math.random(),
                                date: dateStr,
                                ticker: ticker,
                                type: type,
                                quantity: quantity,
                                premium: premium,
                                price: premium,
                                strike: strike,
                                expiry: expiry.toISOString().split('T')[0],
                                status: i > 5 ? 'open' : 'closed',
                                side: 'buy'
                            };
                            
                            appState.positions.push(position);
                            deductFromBalance(cost);
                            
                            appState.ledger.push({
                                id: Date.now() + Math.random(),
                                timestamp: date.toISOString(),
                                action: 'buy',
                                ticker: ticker,
                                type: type,
                                quantity: quantity,
                                price: premium,
                                total: cost,
                                balance: appState.cash + appState.marginAvailable
                            });
                        }
                    } else {
                        // Generate stock trade
                        const price = 100 + Math.random() * 400;
                        const quantity = Math.floor(Math.random() * 100) + 10;
                        const cost = quantity * price;
                        
                        if (cost <= (appState.cash + appState.marginAvailable)) {
                            const position = {
                                id: Date.now() + Math.random(),
                                date: dateStr,
                                ticker: ticker,
                                type: 'stock',
                                quantity: quantity,
                                price: price,
                                status: i > 10 ? 'open' : 'closed',
                                side: 'buy'
                            };
                            
                            appState.positions.push(position);
                            deductFromBalance(cost);
                            
                            appState.ledger.push({
                                id: Date.now() + Math.random(),
                                timestamp: date.toISOString(),
                                action: 'buy',
                                ticker: ticker,
                                type: 'stock',
                                quantity: quantity,
                                price: price,
                                total: cost,
                                balance: appState.cash + appState.marginAvailable
                            });
                            
                            // Randomly close some positions
                            if (i < 20 && Math.random() > 0.5) {
                                const sellDate = new Date(date);
                                sellDate.setDate(sellDate.getDate() + Math.floor(Math.random() * 5) + 1);
                                const sellPrice = price * (0.9 + Math.random() * 0.3);
                                const proceeds = quantity * sellPrice;
                                const pnl = proceeds - cost;
                                
                                position.status = 'closed';
                                position.side = 'sell';
                                
                                appState.ledger.push({
                                    id: Date.now() + Math.random(),
                                    timestamp: sellDate.toISOString(),
                                    action: 'sell',
                                    ticker: ticker,
                                    type: 'stock',
                                    quantity: quantity,
                                    price: sellPrice,
                                    total: proceeds,
                                    pnl: pnl,
                                    balance: appState.cash + appState.marginAvailable + proceeds
                                });
                                
                                addToBalance(proceeds);
                            }
                        }
                    }
                }
            }
            
            updateDashboard();
            loadActivityTiles();
            updateBalances();
            saveData();
        }

        // Data Export/Import Functions
        function exportData() {
            const data = {
                positions: appState.positions,
                ledger: appState.ledger,
                settings: appState.settings,
                cash: appState.cash,
                marginAvailable: appState.marginAvailable,
                marginUsed: appState.marginUsed,
                lockedCollateral: appState.lockedCollateral
            };
            
            const csv = convertToCSV(data);
            downloadCSV(csv, 'plaid-portfolio-export.csv');
            showAIMessage("Data exported successfully! 📁");
        }

        function convertToCSV(data) {
            // Convert ledger to CSV format
            const headers = ['Date', 'Action', 'Ticker', 'Type', 'Quantity', 'Price', 'Total', 'P/L'];
            const rows = data.ledger.map(entry => [
                entry.timestamp,
                entry.action,
                entry.ticker,
                entry.type,
                entry.quantity,
                entry.price,
                entry.total,
                entry.pnl || ''
            ]);
            
            let csv = headers.join(',') + '\n';
            rows.forEach(row => {
                csv += row.map(cell => `"${cell}"`).join(',') + '\n';
            });
            
            return csv;
        }

        function downloadCSV(csv, filename) {
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    // Parse CSV
                    const csv = e.target.result;
                    const lines = csv.split('\n');
                    const headers = lines[0].split(',').map(h => h.replace(/"/g, ''));
                    
                    appState.ledger = [];
                    
                    for (let i = 1; i < lines.length; i++) {
                        if (lines[i].trim() === '') continue;
                        
                        const values = lines[i].split(',').map(v => v.replace(/"/g, ''));
                        const entry = {
                            id: Date.now() + i,
                            timestamp: values[0],
                            action: values[1],
                            ticker: values[2],
                            type: values[3],
                            quantity: parseInt(values[4]),
                            price: parseFloat(values[5]),
                            total: parseFloat(values[6]),
                            pnl: values[7] ? parseFloat(values[7]) : undefined
                        };
                        appState.ledger.push(entry);
                    }
                    
                    updateLedger();
                    updateDashboard();
                    saveData();
                    showAIMessage("Data imported successfully! 📈");
                } catch (error) {
                    showAIMessage("Error importing data. Please check file format.");
                    console.error(error);
                }
            };
            reader.readAsText(file);
        }

        // Data Persistence Functions
        function saveData() {
            if (db) {
                // Save to IndexedDB
                const transaction = db.transaction(['positions', 'ledger', 'settings'], 'readwrite');
                
                // Clear and save positions
                const positionsStore = transaction.objectStore('positions');
                positionsStore.clear();
                appState.positions.forEach(position => {
                    positionsStore.add(position);
                });
                
                // Clear and save ledger
                const ledgerStore = transaction.objectStore('ledger');
                ledgerStore.clear();
                appState.ledger.forEach(entry => {
                    ledgerStore.add(entry);
                });
                
                // Save settings
                const settingsStore = transaction.objectStore('settings');
                settingsStore.put({
                    key: 'appState',
                    data: {
                        cash: appState.cash,
                        marginAvailable: appState.marginAvailable,
                        marginUsed: appState.marginUsed,
                        lockedCollateral: appState.lockedCollateral,
                        settings: appState.settings
                    }
                });
            } else {
                // Fallback to localStorage
                saveToLocalStorage();
            }
        }

        function loadData() {
            if (db) {
                // Load from IndexedDB
                const transaction = db.transaction(['positions', 'ledger', 'settings'], 'readonly');
                
                // Load positions
                const positionsStore = transaction.objectStore('positions');
                positionsStore.getAll().onsuccess = function(event) {
                    appState.positions = event.target.result;
                    updateDashboard();
                    loadActivityTiles();
                };
                
                // Load ledger
                const ledgerStore = transaction.objectStore('ledger');
                ledgerStore.getAll().onsuccess = function(event) {
                    appState.ledger = event.target.result;
                    updateLedger();
                };
                
                // Load settings
                const settingsStore = transaction.objectStore('settings');
                settingsStore.get('appState').onsuccess = function(event) {
                    if (event.target.result) {
                        const data = event.target.result.data;
                        appState.cash = data.cash || 100000;
                        appState.marginAvailable = data.marginAvailable || 50000;
                        appState.marginUsed = data.marginUsed || 0;
                        appState.lockedCollateral = data.lockedCollateral || 0;
                        appState.settings = data.settings || appState.settings;
                    }
                    updateBalances();
                };
            } else {
                // Fallback to localStorage
                loadFromLocalStorage();
            }
        }

        function saveToLocalStorage() {
            localStorage.setItem('plaidPortfolio', JSON.stringify(appState));
        }

        function loadFromLocalStorage() {
            const saved = localStorage.getItem('plaidPortfolio');
            if (saved) {
                const data = JSON.parse(saved);
                appState = { ...appState, ...data };
                updateDashboard();
                loadActivityTiles();
                updateLedger();
                updateBalances();
            }
        }

        // Keyboard Shortcuts
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case 'n':
                        e.preventDefault();
                        openTradeModal();
                        break;
                    case 's':
                        e.preventDefault();
                        saveData();
                        showAIMessage("Data saved! 💾");
                        break;
                }
            } else if (e.key === 'Escape') {
                // Close any open modals
                document.querySelectorAll('.modal.active').forEach(modal => {
                    modal.classList.remove('active');
                });
            }
        });

        // Initialize App
        function initApp() {
            initDB();
            updateBalances();
            updateDashboard();
            
            // Set today's date as default for trade entry
            const today = new Date().toISOString().split('T')[0];
            document.getElementById('tradeDate').value = today;
            
            // Show welcome message
            setTimeout(() => {
                showAIMessage("Welcome to Plaid Portfolio! Press Ctrl+N to add a trade 🚀");
            }, 1000);
        }

        // Start the app when DOM is loaded
        document.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>
                
